# 架构设计 - 自进化编码框架

## 🏗️ 三层架构总览

```
┌─────────────────────────────────────────────────────────┐
│                    Agent Layer (LLM)                    │
│                   不可变的基础能力层                      │
│                                                         │
│  - 语言理解与生成                                        │
│  - 代码推理能力                                          │
│  - 模式识别                                              │
│  - 通用问题解决                                          │
│                                                         │
│  特性：通用、稳定、不可修改                               │
└─────────────────────────────────────────────────────────┘
                            ↑
                            │ 被引导
                            │
┌─────────────────────────────────────────────────────────┐
│                    Skill Layer (索引策略)                │
│                    可进化的指引机制层                     │
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │ Orchestrator│  │  Producer   │  │  Composer   │    │
│  │   总调度器   │  │  生产引擎   │  │  拼装引擎   │    │
│  └─────────────┘  └─────────────┘  └─────────────┘    │
│                                                         │
│  ┌─────────────┐                                       │
│  │   Learner   │  + 索引配置 (.state/indices/)         │
│  │  学习引擎   │    - feature-weights.json             │
│  └─────────────┘    - example-index.json               │
│                     - pattern-index.json               │
│                                                         │
│  特性：可配置、可进化、持续优化                           │
└─────────────────────────────────────────────────────────┘
                            ↑
                            │ 索引指向
                            │
┌─────────────────────────────────────────────────────────┐
│                  Knowledge Layer (知识库)                │
│                  结构化资源仓库层                         │
│                                                         │
│  knowledge/                                             │
│  ├── uefn/                    # UEFN特定知识            │
│  │   ├── api-digests/        # API摘要                 │
│  │   └── capability-map.json # 能力地图                 │
│  ├── patterns/                # 设计模式                │
│  │   ├── zero-coupling.md                              │
│  │   ├── event-driven.md                               │
│  │   └── ...                                           │
│  └── examples/                # 代码案例                │
│      ├── excellent/           # 优秀案例                │
│      └── average/             # 普通案例                │
│                                                         │
│  特性：稳定增长、结构化、可索引                           │
└─────────────────────────────────────────────────────────┘
```

## 📐 层级职责详解

### Agent Layer - 不可变层

**职责**：提供基础的推理和生成能力

**能力范围**：

- ✅ 理解自然语言需求
- ✅ 生成符合语法的代码
- ✅ 识别代码模式
- ✅ 进行逻辑推理

**限制**：

- ❌ 无法记忆历史反馈
- ❌ 无法自我优化策略
- ❌ 无法主动选择上下文

**为什么不可变？**

LLM是预训练模型，我们无法改变其内部参数。即使可以微调，成本也极高且容易过拟合。

**比喻**：Agent像一个博学的顾问，知识广博但不会主动学习你的特定领域偏好。

### Skill Layer - 可进化层

**职责**：引导Agent关注正确的知识

**核心机制**：

1. **索引配置** - 定义"看什么"
2. **披露策略** - 决定"怎么给"
3. **反馈学习** - 优化"看什么"

**4个元Skill**：

```
orchestrator.skill.md
├─ 职责：流程调度，决定何时调用哪个Skill
├─ 输入：用户需求、当前阶段
└─ 输出：调用序列（producer → composer → learner）

producer.skill.md
├─ 职责：探索能力边界，生产代码积木
├─ 输入：能力地图、索引配置
└─ 输出：新代码模块 + 质量评分

composer.skill.md
├─ 职责：根据需求拼装已有积木
├─ 输入：需求、积木库、索引配置
└─ 输出：组装好的功能代码

learner.skill.md
├─ 职责：分析反馈，优化索引配置
├─ 输入：历史产出、质量评分
└─ 输出：更新的索引配置
```

**为什么可进化？**

索引配置是JSON文件，我们可以：

- 读取当前配置
- 分析产出质量
- 计算相关性
- 更新权重数值

**比喻**：Skill像一个助手，记录你的偏好，每次帮你准备最相关的资料给顾问。

### Knowledge Layer - 稳定增长层

**职责**：存储结构化的知识资源

**资源类型**：

```
knowledge/
├── uefn/                          # UEFN领域知识
│   ├── api-digests/               # API参考
│   │   ├── Fortnite.digest.verse.md
│   │   ├── UnrealEngine.digest.verse.md
│   │   └── Verse.digest.verse.md
│   └── capability-map.json        # 能力地图
│
├── patterns/                      # 设计模式
│   ├── zero-coupling.md           # 零耦合模式
│   ├── event-driven.md            # 事件驱动
│   ├── component-based.md         # 组件化
│   └── ...
│
└── examples/                      # 代码案例
    ├── excellent/                 # 高质量案例
    │   ├── HealthComponent.verse
    │   ├── AttackSystem.verse
    │   └── ...
    └── average/                   # 普通案例
        └── ...
```

**特点**：

- **只增不改** - 新案例追加，旧案例保留
- **结构化** - 按类型、质量分类
- **可索引** - 支持权重化检索

**比喻**：Knowledge像图书馆，书籍不断增加，但每本书的内容不变。

## 🔄 数据流向

### 生产循环 (Producer)

```
1. Orchestrator 启动
   ↓
2. 读取能力地图
   capability-map.json → 待探索能力列表
   ↓
3. 读取索引配置
   feature-weights.json → 当前权重分布
   ↓
4. Producer 渐进式披露
   ├─ 权重 > 0.85 → 披露完整模式文档
   ├─ 权重 0.60-0.85 → 披露摘要
   └─ 权重 < 0.60 → 不披露
   ↓
5. Agent 生成代码
   基于披露的上下文 → HealthComponent.verse
   ↓
6. Learner 分析质量
   ├─ 评估代码质量 → 0.82
   ├─ 分析特征相关性
   └─ 更新索引权重
   ↓
7. 循环回到步骤3（使用新索引）
```

### 拼装循环 (Composer)

```
1. 接收真实需求
   "实现玩家战斗系统"
   ↓
2. 分解需求
   ├─ 健康管理
   ├─ 伤害计算
   ├─ 技能释放
   └─ UI反馈
   ↓
3. 读取索引配置
   example-index.json → 优秀案例列表
   ↓
4. 检索积木库
   assets/modules/
   ├─ ✓ HealthComponent.verse (找到)
   ├─ ✓ DamageCalculator.verse (找到)
   ├─ ✗ SkillSystem.verse (缺失)
   └─ ✓ CombatUI.verse (找到)
   ↓
5. Composer 拼装
   ├─ 80%由积木组成
   └─ 20%现场生成（SkillSystem）
   ↓
6. 输出完整系统
   CombatSystem.verse
```

### 学习循环 (Learner)

```
1. 收集反馈数据
   data/experiences/
   ├─ 产出1：质量0.65，特征分布
   ├─ 产出2：质量0.75，特征分布
   └─ 产出N：质量0.87，特征分布
   ↓
2. 特征相关性分析
   计算：特征X权重 ↔ 产出质量
   ├─ zero_coupling: 相关系数 0.92
   ├─ modularity: 相关系数 0.85
   └─ naming: 相关系数 0.65
   ↓
3. 权重更新算法
   新权重 = 旧权重 × (1-α) + 相关系数 × α
   (α = 学习率，如 0.2)
   ↓
4. 更新索引配置
   .state/indices/feature-weights.json
   {
     "zero_coupling": 0.92,  // 0.5 → 0.92
     "modularity": 0.85,     // 0.5 → 0.85
     "naming": 0.65          // 0.5 → 0.65
   }
   ↓
5. 影响下一轮披露策略
```

## 🎯 不可变层 vs 可变层

### 为什么要分层？

| 层级 | 为什么不可变？ | 为什么可变？ |
|-----|--------------|-------------|
| **Agent** | LLM是黑盒，无法修改内部权重 | - |
| **Skill** | - | JSON配置文件，可读写更新 |
| **Knowledge** | 知识积累，历史不应改变 | - |

### 进化发生在哪？

```
✗ 不在Agent层
  - 我们无法改变GPT-4的参数

✓ 在Skill层
  - feature-weights.json: {"zero_coupling": 0.5} → 0.92
  - example-index.json: 案例排序不断优化
  - pattern-index.json: 模式引用频率调整

✗ 不在Knowledge层
  - 案例不修改，只增加
  - 模式文档不变，只扩充
```

**关键洞察**：我们不改变"工具的能力"，而是改变"如何使用工具"。

## 🔍 渐进式披露机制详解

### 传统方式：全量披露

```
给Agent的上下文：
├─ 100页UEFN文档
├─ 50个代码案例
├─ 20种设计模式
└─ 所有API参考

问题：
├─ 超出上下文窗口限制
├─ Agent无法抓住重点
└─ 质量不稳定（0.60-0.70）
```

### 框架方式：权重化披露

```
步骤1：读取索引
{
  "zero_coupling": 0.92,    ← 高权重
  "modularity": 0.85,       ← 高权重
  "naming": 0.65,           ← 中权重
  "comments": 0.40          ← 低权重
}

步骤2：选择性披露
├─ 0.92 权重 → 完整披露 zero_coupling.md + 3个案例
├─ 0.85 权重 → 完整披露 modularity.md + 2个案例
├─ 0.65 权重 → 摘要披露 naming规范（1段）
└─ 0.40 权重 → 不披露 comments相关

步骤3：Agent聚焦
基于"最相关的20%"生成代码
→ 质量稳定在 0.85+
```

### 披露策略矩阵

| 权重范围 | 披露程度 | 案例数量 | 模式文档 |
|---------|---------|---------|---------|
| 0.85-1.0 | 完整 | 3个优秀案例 | 完整文档 |
| 0.70-0.85 | 详细 | 2个案例 | 详细摘要 |
| 0.50-0.70 | 摘要 | 1个案例 | 简要说明 |
| 0.30-0.50 | 提及 | 0个 | 仅标题 |
| 0-0.30 | 不披露 | 0个 | 无 |

## 🧩 架构设计原则

### 1. 关注点分离

```
Agent   → 专注推理和生成
Skill   → 专注策略和引导
Knowledge → 专注存储和组织
```

### 2. 单向依赖

```
Agent ← 使用 ← Skill ← 索引 ← Knowledge
```

不存在反向依赖，保证系统清晰。

### 3. 可观测性

每个层级的输入输出都可记录：

```
data/traces/
├── producer-run-001.json
│   ├─ input: 索引配置
│   ├─ disclosed: 披露的上下文
│   ├─ output: 生成的代码
│   └─ quality: 质量评分
└── ...
```

### 4. 可测试性

每个Skill独立可测：

```bash
# 测试Producer
input: feature-weights.json (mock)
output: 验证是否按权重披露

# 测试Learner
input: 历史数据 (mock)
output: 验证权重更新逻辑
```

## 📊 架构优势

### 对比传统方法

| 维度 | 传统AI辅助 | 本框架 |
|-----|-----------|--------|
| **上下文管理** | 全量塞入 | 权重化披露 |
| **质量稳定性** | 随机波动 | 持续提升 |
| **知识积累** | 无 | 结构化存储 |
| **可进化性** | 无 | 索引持续优化 |
| **可追溯性** | 难 | 完整trace日志 |

### 扩展性

```
添加新能力：
├─ Knowledge层 → 添加新模式文档
├─ Skill层 → 索引配置自动学习
└─ Agent层 → 无需改动

添加新Skill：
├─ 定义新的.skill.md
├─ 编写披露策略
└─ 注册到orchestrator
```

## 🔗 与其他架构模式的关系

### vs MVC (Model-View-Controller)

```
MVC关注：UI与业务逻辑分离
本框架关注：AI能力与引导策略分离
```

### vs 微服务架构

```
微服务：功能模块独立部署
本框架：知识模块独立索引
```

### vs 插件系统

```
插件：扩展功能
本框架：扩展知识 + 优化策略
```

## 📖 下一步

- **理解核心概念** → [02-core-concepts.md](./02-core-concepts.md)
- **查看项目结构** → [03-project-structure.md](./03-project-structure.md)
- **学习Skill定义** → [04-skill-definitions.md](./04-skill-definitions.md)

---

**返回** → [框架文档首页](./README.md)
