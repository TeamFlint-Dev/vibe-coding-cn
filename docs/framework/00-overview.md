# 系统概述 - 自进化编码框架

## 📌 30秒电梯演讲

**自进化编码框架**是一个AI辅助的代码生产系统，它：

1. **自动化生产**代码积木，系统化覆盖UEFN能力
2. **持续优化**上下文披露策略，让AI产出质量螺旋上升
3. **胶水拼装**积木应对真实需求，80%功能无需从零开发

**核心创新**：不改变AI能力，而是让AI被**越来越精准地引导**。

## 🎯 解决的问题

### 传统AI辅助开发的困境

| 问题 | 表现 | 后果 |
|-----|------|------|
| **重复造轮子** | 每次都从零写代码 | 浪费时间，质量不稳定 |
| **上下文过载** | 一次性塞给AI太多信息 | AI迷失重点，产出质量低 |
| **无法进化** | AI不会从历史中学习 | 犯同样的错误，质量无法提升 |
| **能力盲区** | 不知道UEFN有哪些能力 | 只用20%的API，错失高级功能 |

### 框架的解决方案

```
┌─────────────────────────────────────────────────┐
│                                                 │
│  Producer循环：自动探索能力 → 生产代码积木     │
│  Skill进化：分析反馈 → 优化索引策略              │
│  Composer拼装：需求来临 → 快速组装积木          │
│                                                 │
│  结果：从随机披露 → 精准披露 → 质量螺旋上升     │
│                                                 │
└─────────────────────────────────────────────────┘
```

## 💡 核心创新点

### 1. 渐进式披露机制 (Progressive Disclosure)

**传统做法**：把所有文档、案例、模式一股脑给AI

```
AI收到：100页文档 + 50个案例 + 20种模式
结果：信息过载，抓不住重点 → 质量0.60
```

**框架做法**：根据**索引权重**选择性披露

```
第1步：读取索引 → zero_coupling权重0.92（高）
第2步：只披露 → zero_coupling相关模式 + 3个优秀案例
第3步：AI聚焦关键点 → 质量0.87
```

**关键区别**：披露的是"**最相关的20%**"，而非"**所有的100%**"

### 2. 反馈驱动的索引优化

**进化的本质**：不是让AI变聪明，而是让**指引变精准**

```
第1轮：索引随机（权重全0.5）
  ↓ 产出质量0.65，分析反馈
  ↓ 发现：zero_coupling与高质量强相关

第2轮：更新索引（zero_coupling: 0.5 → 0.85）
  ↓ 披露策略改进，质量0.75 ↑
  ↓ 继续分析，发现：modularity也重要

第10轮：索引精准（权重分布合理）
  ↓ 质量0.87+ ↑↑
```

### 3. 三层架构清晰职责

```
┌──────────────────────────────────────────┐
│  Agent (LLM)        - 不可变的基础能力   │  ← 通用推理能力
├──────────────────────────────────────────┤
│  Skill (索引策略)   - 可进化的指引机制   │  ← 这里是进化的核心
├──────────────────────────────────────────┤
│  Knowledge (知识库) - 结构化资源仓库     │  ← 案例、模式、API文档
└──────────────────────────────────────────┘
```

**为什么这样设计？**

- **Agent不变** - LLM是黑盒，我们无法改变其内部
- **Skill可变** - 索引配置是JSON，我们完全可控
- **Knowledge稳定** - 知识积累，只增不减

**进化发生在哪？** → Skill层的索引权重配置

## 🔄 系统运作原理

### 循环目标：从随机到精准

```
初始状态：
  索引权重随机分布
  披露内容缺乏针对性
  AI产出质量中等（0.65）
  
经过N轮循环：
  Learner分析质量反馈
  识别高相关特征
  调整索引权重分布
  
最终状态：
  索引权重精准分布
  披露内容高度相关
  AI产出质量优秀（0.87+）
```

### 完整循环示例

**场景**：生产一个"玩家健康管理"组件

```
┌─ Orchestrator 调度 ─────────────────────────┐
│                                             │
│  1. Producer生产阶段                         │
│     ├─ 读取索引: feature-weights.json       │
│     │   zero_coupling: 0.92 (高权重)        │
│     │   modularity: 0.85                    │
│     │                                        │
│     ├─ 渐进式披露:                           │
│     │   ✓ 披露 zero_coupling 模式            │
│     │   ✓ 披露 3个高质量案例                  │
│     │   ✗ 不披露 低权重模式（节省上下文）      │
│     │                                        │
│     └─ Agent生成代码 → HealthComponent.verse │
│                                             │
│  2. Learner学习阶段                          │
│     ├─ 评估质量: 0.82 (良好)                 │
│     ├─ 特征分析:                             │
│     │   zero_coupling: 完美遵守 → 权重维持   │
│     │   modularity: 表现优秀 → 权重↑          │
│     │   naming: 不理想 → 权重↑                │
│     │                                        │
│     └─ 更新索引: naming: 0.60 → 0.75         │
│                                             │
│  3. 下一轮循环（披露策略已优化）              │
│                                             │
└─────────────────────────────────────────────┘
```

## 🎨 与现有系统的关系

### 基于现有架构扩展

本框架**不是替代**，而是**增强**现有系统：

```
现有系统 (Core/skills/)
├── verseDev/          ← 保留，继续使用
├── gameDev/           ← 保留，继续使用
└── ...

框架扩展
├── 4个元Skill          ← 新增
│   ├── orchestrator   (总调度)
│   ├── producer       (生产引擎)
│   ├── composer       (拼装引擎)
│   └── learner        (学习引擎)
│
├── 索引机制            ← 新增
│   └── .state/indices/
│       ├── feature-weights.json
│       ├── example-index.json
│       └── pattern-index.json
│
└── 知识库结构化        ← 整理现有资源
    └── knowledge/
        ├── uefn/
        └── patterns/
```

### 协作关系

| 层级 | 现有系统 | 框架扩展 | 关系 |
|-----|---------|---------|------|
| **元控制** | 无 | orchestrator.skill.md | 新增总调度 |
| **Skill** | verseDev/*, gameDev/* | producer/composer/learner | 元Skill调用现有Skill |
| **Knowledge** | api-digests, references | knowledge/ | 结构化组织现有资源 |
| **索引** | 无 | .state/indices/ | 新增进化机制 |

**关键**：现有Skill无需修改，通过索引机制被更精准地调用。

## 📊 预期效果

### 质量提升曲线

```
质量分数
  ↑
0.90 |                         ........目标线
     |                     ....
0.85 |                 ....
     |             ....
0.80 |         ....
     |     ....
0.75 | ....
     |.
0.70 |
     |
0.65 |●
     └─────────────────────────────────────→ 循环轮数
        1  2  3  4  5  6  7  8  9  10

● 第1轮：随机索引，质量基准
... 后续轮次：索引优化，质量爬升
```

### 开发效率提升

| 阶段 | 传统开发 | 使用框架 | 提升 |
|-----|---------|---------|------|
| **需求分析** | 2小时 | 1小时 | 50% |
| **代码编写** | 8小时 | 2小时（拼装积木） | 75% |
| **调试修复** | 4小时 | 1小时（积木已测试） | 75% |
| **总计** | 14小时 | 4小时 | **71%** |

**关键**：80%功能由已有积木拼装，只需开发剩余20%。

## 🚦 适用场景

### ✅ 适合使用框架

- UEFN/Verse游戏开发
- 需要大量代码组件（战斗、UI、道具等）
- 项目周期长，需持续优化
- 团队希望建立代码资产库

### ⚠️ 不适合使用框架

- 一次性原型项目
- 代码规模小（< 1000行）
- 无需复用组件
- 团队无AI辅助开发经验

## 🎯 核心价值主张

### 对开发者

- **减少重复劳动** - 积木复用率80%
- **质量持续提升** - 每轮循环都在优化
- **能力全覆盖** - 系统化探索UEFN所有功能

### 对团队

- **知识沉淀** - 代码积木 + 案例 + 模式形成资产
- **新人友好** - 通过拼装积木快速上手
- **标准化** - 所有组件遵循统一架构

### 对项目

- **开发提速** - 需求到交付时间缩短70%
- **质量稳定** - 积木都经过测试和优化
- **可维护性** - 组件解耦，易于修改

## 📖 下一步

- **理解架构** → 阅读 [01-architecture.md](./01-architecture.md)
- **掌握概念** → 阅读 [02-core-concepts.md](./02-core-concepts.md)
- **开始实施** → 阅读 [08-implementation-guide.md](./08-implementation-guide.md)

---

**返回** → [框架文档首页](./README.md)
