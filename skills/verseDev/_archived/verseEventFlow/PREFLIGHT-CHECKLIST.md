# verseEventFlow 前置检查清单

> **用途**: 开始事件流设计前，逐项检查以避免踩坑
>
> **来源**: 本清单从实际踩坑中持续沉淀，每条都有对应的失败案例编号

---

## ⚡ 快速检查（每次必看）

- [ ] 读取 `CAPABILITY-BOUNDARIES.md` 确认任务可行性
- [ ] 绘制 Entity 层级树，确认事件传播路径
- [ ] 确认事件类型已在设计文档中定义
- [ ] 检查是否会产生事件循环
- [ ] 验证事件传播策略选择正确（SendUp/SendDown/SendDirect）

> **要求**: 事件流设计必须先于组件实现

---

## 📋 架构设计检查

### Entity 层级结构

- [ ] Entity 树结构已明确
  - 来源: SceneGraph 框架约束
  - 验证: 绘制树形图，标注每个 Entity 的名称和职责
  
- [ ] 事件发送方和接收方在同一树内
  - 来源: 事件只在树内传播
  - 验证: 确认发送方和接收方有共同的根节点
  
- [ ] 全局事件有根 Entity 负责分发
  - 来源: 跨分支通信需要根节点中转
  - 验证: 确认根 Entity 可以 SendDown 到所有子系统

### 事件传播路径

- [ ] SendUp 用于子向父报告
  - 来源: 事件传播机制
  - 场景: 玩家得分、组件状态变化报告给管理器
  
- [ ] SendDown 用于父向子广播
  - 来源: 事件传播机制
  - 场景: 游戏状态变化、全局配置更新
  
- [ ] SendDirect 用于点对点通信
  - 来源: 事件传播机制
  - 场景: 碰撞通知、直接交互

---

## 🔍 事件类定义检查

### 事件类基础

- [ ] 事件类继承 `scene_event`
  - 来源: SceneGraph 事件系统要求
  - 验证: `class<concrete>(scene_event)`
  
- [ ] 事件类使用 `<concrete>` 标记
  - 来源: 运行时类型识别需要
  - 验证: 编译检查
  - 常见错误: 忘记 `<concrete>` 导致类型转换失败
  
- [ ] 事件类已在设计文档中定义
  - 来源: 架构设计规范
  - 位置: `@architecture-blueprint.md` 或独立事件流文档

### 事件命名

- [ ] 事件名称使用过去时
  - 来源: 语义化命名约定
  - 示例: `player_scored_event`, `health_changed_event`
  - 错误示例: `score_player_event`, `change_health_event`
  
- [ ] 事件名称清晰表达含义
  - 来源: 代码可读性
  - 验证: 他人能通过名称理解事件用途

### 事件数据

- [ ] 事件字段使用不可变类型
  - 来源: 事件应该是只读的
  - 验证: 优先使用 `int`, `float`, `string`, `vector3`
  - 避免: 传递可变的 component 或 entity（只传引用）
  
- [ ] 事件携带必要且最小的数据
  - 来源: 性能和清晰性
  - 验证: 每个字段都有明确用途，无冗余

---

## 🔄 事件处理检查

### OnReceive 实现

- [ ] 重写 `OnReceive<override>()` 方法
  - 来源: 事件接收机制
  - 验证: 包含 `<override>` 标记
  
- [ ] 使用 `?` 类型转换过滤事件
  - 来源: 类型安全
  - 验证: `if (MyEvent := Event?my_event):`
  
- [ ] 正确返回 `true/false`
  - 来源: 事件消耗机制
  - 规则:
    - `return true` - 消耗事件，阻止继续传播
    - `return false` - 不消耗，允许其他接收者处理

### 异步处理

- [ ] 异步处理器声明 `<suspends>`
  - 来源: Verse 协程约束
  - 验证: `OnReceive<override>()<suspends>:logic`
  
- [ ] 长时间操作使用 `spawn{}`
  - 来源: 避免阻塞事件系统
  - 验证: 复杂逻辑在协程中执行
  - 示例:
    ```verse
    OnReceive<override>(Event:scene_event):logic =
        if (E := Event?long_task_event):
            spawn{ ProcessLongTask(E) }  # 不阻塞
            return true
        return false
    ```

---

## 🎯 事件循环防护检查

### 循环检测

- [ ] 检查是否存在事件循环路径
  - 来源: 事件循环导致栈溢出
  - 验证: 绘制事件流图，检查是否有环
  - 常见模式:
    - A 发送事件 → B 接收 → B 发送事件 → A 接收 ❌
  
- [ ] 实现循环防护机制（如有风险）
  - 来源: 防止无限递归
  - 方案:
    - 状态标记（`IsProcessing` 标志）
    - 事件计数器（限制最大触发次数）
    - 单向流设计（只子向父，不父向子）

### 性能考虑

- [ ] 避免在 `OnSimulate` 中频繁发送事件
  - 来源: OnSimulate 每帧调用
  - 替代: 批量发送或使用定时器
  
- [ ] 事件携带数据量合理
  - 来源: 性能优化
  - 验证: 避免传递大数组、大字符串
  - 推荐: 只传递索引或引用

---

## 📐 生命周期编排检查

### 初始化顺序

- [ ] 组件初始化依赖已明确
  - 来源: OnBeginSimulation 调用顺序不确定
  - 验证: 列出哪些组件需要先初始化
  
- [ ] 简单依赖使用延迟初始化
  - 来源: 避免顺序问题
  - 方案: 在 OnBeginSimulation 中 `Sleep(0.0)` 后再初始化
  
- [ ] 复杂依赖使用 LifecycleManager
  - 来源: 需要精确控制顺序
  - 验证: 引入 `verse/modules/LifecycleManager/`

---

## 🔐 合规性检查

### SceneGraph 约束

- [ ] 事件传播路径符合树结构
  - 来源: SceneGraph 架构约束
  - 验证: 无跨树传播、无逆向传播（子不能 SendDown）
  
- [ ] 事件消耗机制使用正确
  - 来源: 避免意外阻止其他接收者
  - 验证: 确认 `return true` 是有意为之

### 代码质量

- [ ] 事件处理器有错误处理
  - 来源: 接收到的事件可能不完整
  - 验证: 检查字段有效性
  - 示例:
    ```verse
    if (E := Event?damage_event):
        if E.Amount <= 0:  # 验证数据
            Print("警告：无效伤害值")
            return true
        # 正常处理...
    ```

---

## 🧪 测试验证

### 事件流测试

- [ ] 使用日志追踪事件发送和接收
  - 来源: 调试事件流
  - 方案: 在发送和接收处添加 `Print()`
  
- [ ] 测试事件未被接收的情况
  - 来源: 容错性
  - 验证: 接收者不存在时，发送者不应崩溃
  
- [ ] 测试事件传播是否按预期路径
  - 来源: 架构验证
  - 方案: 多个接收者添加日志，确认传播范围

### 边界测试

- [ ] 测试事件字段为空的情况
  - 来源: 数据健壮性
  - 验证: 可选类型字段可能为 `false`
  
- [ ] 测试高频事件的性能
  - 来源: 性能优化
  - 验证: OnSimulate 中每帧发送不会导致卡顿

---

## 🔨 编译验证

- [ ] 事件类编译通过
  - 验证: `<concrete>` 标记正确
  
- [ ] 事件类型转换无警告
  - 验证: `Event?my_event` 不报类型错误
  
- [ ] 远程编译验证通过
  - 验证: `.\tools\verseCompiler\client\compile.ps1 -Wait`

---

## 📝 文档检查

- [ ] 事件流图已绘制
  - 来源: 架构可视化
  - 位置: `@architecture-blueprint.md` 或独立文档
  
- [ ] 事件类有注释说明用途
  - 来源: 代码可读性
  - 格式: `# player_scored_event - 玩家得分时触发`
  
- [ ] 复杂事件链有说明
  - 来源: 维护性
  - 验证: 事件 A → B → C 的流程有注释

---

## 更新记录

| 日期 | 更新内容 | 关联案例 |
|------|----------|----------|
| 2026-01-06 | 初始版本，基于 SKILL.md 和 SceneGraph 框架 | - |

---

## 如何使用本清单

1. **任务开始前**: 从上到下逐项检查
2. **发现问题**: 停止任务，先解决问题
3. **踩坑后**: 立即更新清单，添加新检查项
4. **定期回顾**: 每月检查清单是否仍然有效
