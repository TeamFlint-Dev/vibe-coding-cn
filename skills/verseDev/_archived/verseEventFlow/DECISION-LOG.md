# verseEventFlow 决策记录

> **用途**: 记录重要的技术决策及其理由
>
> **原则**: 记录"为什么"比"是什么"更重要

---

## 决策索引

| ID | 决策标题 | 状态 | 日期 |
|----|----------|------|------|
| DR-001 | 选择 SceneGraph 原生事件系统 vs 自定义事件总线 | 已决定 | 2026-01-04 |
| DR-002 | 事件命名使用过去时 | 已决定 | 2026-01-04 |

<!-- 索引模板：
| DR-XXX | 决策标题 | 已决定/待讨论/已废弃 | YYYY-MM-DD |
-->

---

## 状态说明

| 状态 | 含义 |
|------|------|
| 待讨论 | 正在评估，尚未最终确定 |
| 已决定 | 已做出决策，正在执行 |
| 已废弃 | 决策被推翻或不再适用 |

---

## 决策详情

### DR-001: 选择 SceneGraph 原生事件系统 vs 自定义事件总线

**日期**: 2026-01-04
**状态**: 已决定
**决策者**: 架构设计（基于 verseEventFlow 研究）

#### 上下文

在设计组件间通信机制时，有两种选择：
1. 使用 SceneGraph 框架内置的事件系统
2. 实现自定义的全局事件总线

#### 问题陈述

如何实现高效、可靠的组件间通信？

#### 选项分析

##### 选项 A: SceneGraph 原生事件系统

```verse
# 使用内置事件系统
Owner.SendUp(player_scored_event{Player := MyPlayer, Score := 100})

OnReceive<override>(Event:scene_event):logic =
    if (ScoreEvent := Event?player_scored_event):
        HandleScore(ScoreEvent)
        return true
    return false
```

- 优点: 
  - 框架原生支持，性能优化
  - 无需额外依赖
  - 与 Entity 树结构自然集成
  - 事件生命周期由框架管理
- 缺点: 
  - 只能在 Entity 树内传播
  - 无法跨场景通信
  - 调试工具有限
- 技术风险: 低
- 实现成本: 低

##### 选项 B: 自定义全局事件总线

```verse
# 自定义事件总线
EventBus.Subscribe("player_scored", HandleScore)
EventBus.Publish("player_scored", {Player := MyPlayer, Score := 100})
```

- 优点: 
  - 全局可访问
  - 可自定义功能（优先级、队列等）
  - 灵活的订阅/取消订阅机制
- 缺点: 
  - 需要实现和维护
  - 性能可能不如原生系统
  - 增加复杂度
  - 需要管理内存泄漏风险
- 技术风险: 中
- 实现成本: 高

#### 决策

选择 **选项 A: SceneGraph 原生事件系统**

对于需要全局通信的场景，使用 **EventBus 模块作为补充**（基于原生系统的轻量级封装）

#### 理由

1. **性能优先**: 原生系统经过 Epic 优化，性能有保障
2. **架构一致性**: 与 SceneGraph 框架的 Entity 树结构自然集成
3. **维护成本低**: 无需自己实现复杂的事件系统
4. **80/20 原则**: 80% 的通信场景都在 Entity 树内，可用原生系统
5. **可扩展性**: 对于 20% 需要全局通信的场景，用 EventBus 模块补充

#### 后果

- **正面**: 
  - 开发效率高，无需重新发明轮子
  - 性能稳定可靠
  - 代码简洁，易于理解
  
- **负面**: 
  - 受限于 Entity 树结构
  - 跨场景通信需要其他方案
  - 调试工具有限
  
- **需要注意**: 
  - 必须遵守 Entity 树的层级结构
  - 全局广播需通过根 Entity
  - 对于跨场景需求，使用持久化存储或 EventBus 模块

#### 实施要点

- [x] 优先使用 SendUp/SendDown/SendDirect
- [x] 创建 EventBus 模块处理全局通信场景
- [x] 在 SKILL.md 中明确使用场景划分

#### 相关

- 相关决策: [DR-002](#dr-002-事件命名使用过去时)
- 相关文档: [SKILL.md](SKILL.md)
- 相关模块: `verse/modules/EventBus/`

---

### DR-002: 事件命名使用过去时

**日期**: 2026-01-04
**状态**: 已决定
**决策者**: 命名规范委员会

#### 上下文

事件表示"已经发生的事情"，需要统一命名规范。

#### 问题陈述

事件名称应该用现在时、将来时还是过去时？

#### 选项分析

##### 选项 A: 现在时（如 `player_score_event`）

- 优点: 简洁
- 缺点: 不清楚是"正在得分"还是"已得分"

##### 选项 B: 将来时（如 `player_will_score_event`）

- 优点: 明确表达意图
- 缺点: 不符合事件"已发生"的语义

##### 选项 C: 过去时（如 `player_scored_event`）

- 优点: 清晰表达"已发生"，符合事件语义
- 缺点: 略长

#### 决策

选择 **选项 C: 过去时**

#### 理由

1. **语义清晰**: 事件表示已经发生的事实
2. **行业惯例**: 主流事件驱动系统（如 .NET, Java）都使用过去时
3. **可读性**: 代码更易理解（"玩家得分了"vs"玩家得分"）

#### 后果

- **正面**: 代码可读性提升，语义明确
- **负面**: 事件名称略长
- **需要注意**: 所有事件必须遵守此规范

#### 实施要点

- [x] 更新 SKILL.md 明确命名规范
- [x] 添加到 PREFLIGHT-CHECKLIST.md
- [ ] 审查现有事件，统一命名

#### 相关

- 相关文档: [SKILL.md - 事件设计原则](SKILL.md#事件设计原则)

---

## 如何添加新决策

1. 复制模板
2. 分配递增的 DR 编号
3. 填写所有字段
4. 更新顶部索引表
5. 提交并推送到远程

---

## 统计

- 总决策数: 2
- 按状态分布: 已决定 2
- 最近更新: 2026-01-06
