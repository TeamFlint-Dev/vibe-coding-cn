# SG/Device 心智模型迁移前后对比

> **文档目的**: 清晰对比旧模型与新模型的差异，验证迁移效果  
> **创建日期**: 2026-01-05

---

## 📊 核心定义对比

| 维度 | 旧模型 (v1.0) | 新模型 (v2.0) |
|------|--------------|--------------|
| **核心思想** | "SG 处理逻辑，Device 处理交互" | "**SG能力边界 = Component化边界**" |
| **分类依据** | 功能类型（逻辑 vs 交互） | 技术可行性（可否 Component化） |
| **决策难点** | 很多功能既有逻辑又有交互，难以分类 | 清晰的5项检查标准，易于判定 |
| **理论基础** | 经验总结，缺乏统一原则 | 基于 SceneGraph 组件化架构本质 |
| **与官方定位** | 部分对齐 | 完全对齐（SceneGraph = 组件化系统） |

---

## 🔍 决策流程对比

### 旧模型决策流程

```
收到需求
    │
    ▼
这是逻辑功能还是交互功能？
    │
    ├─ 逻辑功能 → 用 SceneGraph
    │               │
    │               └─ 但需要输入怎么办？❓
    │
    └─ 交互功能 → 用 Device
                    │
                    └─ 但有复杂状态怎么办？❓
```

**问题**: 分类模糊、决策困难、缺乏明确指引

---

### 新模型决策流程

```
收到需求
    │
    ▼
分解功能点
    │
    ▼
对每个功能点进行 Component化判定（5项检查）
    │
    ├─ 可 Component化 → SceneGraph (Component)
    │
    ├─ 不可 Component化 → Device
    │
    └─ 混合 → Component 管理逻辑 + Device 提供能力
```

**优势**: 
- ✅ 标准清晰（5项检查）
- ✅ 决策明确（技术可行性）
- ✅ 支持混合架构
- ✅ 可验证可复现

---

## 💡 典型案例对比

### 案例1: 钓鱼系统

#### 旧模型分析

```
钓鱼系统 → 是交互功能 → 用 Device ❓

问题：
- 钓鱼也有复杂状态管理（状态机、进度计算）
- 如果都用 Device，逻辑如何组织？
- SceneGraph 和 Device 如何配合？不清楚
```

**结论**: 决策困难，缺乏明确指引

---

#### 新模型分析

```
钓鱼系统功能分解：
1. 钓鱼状态机 → Component化判定：✅✅✅✅✅ (5/5) → Component
2. 进度计算 → Component化判定：✅✅✅✅✅ (5/5) → Component (Helper)
3. 玩家输入 → Component化判定：❌❌❌❌❌ (0/5) → Device (引擎依赖)
4. UI显示 → Component化判定：❌❌❌❌❌ (0/5) → Device (编辑器预置)
5. 音效播放 → Component化判定：❌❌❌❌❌ (0/5) → Device (资源绑定)

架构方案：混合架构
- Component 持有状态和逻辑（fishing_component）
- Device 提供能力（input/audio/ui_device）
- 协作方式：Device 事件触发 Component 逻辑
```

**结论**: 决策清晰，架构明确，职责分明

---

### 案例2: 敌人波次生成

#### 旧模型分析

```
波次生成 → 是逻辑功能 → 用 SceneGraph ✓

但是：
- 需要播放音效 → 怎么办？
- 需要显示UI提示 → 怎么办？
- 能否混用 Device？如何混用？不明确
```

**结论**: 基本方向正确，但混合使用缺乏指引

---

#### 新模型分析

```
波次生成功能分解：
1. 波次管理 → Component化判定：✅✅✅✅✅ (5/5) → Component
2. 敌人生成 → Component化判定：✅✅✅✅✅ (5/5) → Component
3. 路径规划 → Component化判定：✅✅✅✅✅ (5/5) → Component
4. 音效播放 → Component化判定：❌❌❌❌❌ (0/5) → Device
5. UI提示 → Component化判定：❌❌❌❌❌ (0/5) → Device

架构方案：混合架构
- Component 管理逻辑（wave_manager_component + spawner_component）
- Device 提供输出（audio/ui_device）
- 明确的混合模式：Component 通过 @editable 引用 Device
```

**结论**: 不仅确定用 SceneGraph，还明确了如何混用 Device

---

### 案例3: UI菜单系统

#### 旧模型分析

```
UI菜单 → 是交互功能 → 用 Device ✓

正确，但：
- 复杂菜单状态如何管理？
- 能否用 Component 管理状态？不确定
```

**结论**: 基本正确，但细节不明确

---

#### 新模型分析

```
UI菜单功能分解：
1. UI布局 → Component化判定：❌❌❌❌❌ (0/5) → Device（编辑器预置）
2. 菜单状态 → Component化判定：✅✅✅✅✅ (5/5) → Component（可选）
3. 按钮逻辑 → Component化判定：❌❌❌❌❌ (0/5) → Device

架构方案：
- 简单菜单：纯 Device
- 复杂菜单：可选 Component 管理状态 + Device 渲染
```

**结论**: 提供了灵活性和选择指引

---

## 📝 术语对比

| 概念 | 旧模型说法 | 新模型说法 |
|------|-----------|-----------|
| **SceneGraph 用途** | "处理逻辑" | "实现可 Component化的功能" |
| **Device 用途** | "处理交互" | "实现不可 Component化的功能" |
| **混合架构** | "SG 管理逻辑，Device 处理交互" | "Component 持有状态，Device 提供能力" |
| **决策标准** | "功能类型" | "Component化可行性（5项检查）" |
| **能力边界** | "原生能力 vs 需要 Device 的功能" | "可 Component化 vs 不可 Component化" |

---

## ✅ 迁移效果评估

### 解决的问题

| 旧模型问题 | 新模型解决方案 | 效果评级 |
|-----------|---------------|---------|
| 分类模糊 | 5项清晰的检查标准 | ⭐⭐⭐⭐⭐ |
| 决策困难 | 技术可行性判定，黑白分明 | ⭐⭐⭐⭐⭐ |
| 混合架构混乱 | 明确的混合架构模式 | ⭐⭐⭐⭐⭐ |
| 与官方定位不符 | 完全对齐 SceneGraph 组件化本质 | ⭐⭐⭐⭐⭐ |
| 缺乏可验证性 | 5项检查可量化、可验证 | ⭐⭐⭐⭐⭐ |

### 保留的优势

| 旧模型优势 | 新模型保留 |
|-----------|-----------|
| 基于官方文档的能力梳理 | ✅ 完全保留，并增强 |
| 典型用例分类 | ✅ 保留并重新归类 |
| 限制说明 | ✅ 保留并关联到 Component化不可行原因 |
| 最佳实践 | ✅ 保留并扩展（混合架构模式） |

---

## 🎯 实际应用对比

### 开发者视角

**旧模型**:
```
开发者: "我要做一个钓鱼系统，该用 SceneGraph 还是 Device？"
文档: "钓鱼是交互功能，用 Device"
开发者: "但我有复杂状态管理，Device 怎么管理？"
文档: "..." （缺乏指引）
```

**新模型**:
```
开发者: "我要做一个钓鱼系统，该用 SceneGraph 还是 Device？"
文档: "先做 Component化判定，分解功能点，每个功能点进行5项检查"
开发者: "状态机可 Component化，输入不可，UI不可，音效不可"
文档: "推荐混合架构：Component 管理状态，Device 提供输入/UI/音效"
开发者: "明白了！具体怎么写？"
文档: "参考混合架构模式示例代码" ✅
```

---

### AI Agent 视角

**旧模型**:
```
Agent 收到需求："实现钓鱼系统"
Agent 分析："钓鱼涉及交互，应该用 Device"
Agent 设计："用 Device 实现..." ❌
问题：状态管理复杂度高，Device 不适合
```

**新模型**:
```
Agent 收到需求："实现钓鱼系统"
Agent 执行 Component化判定：
  - 状态机：✅ 可 Component化
  - 输入：❌ 不可
  - UI：❌ 不可
  - 音效：❌ 不可
Agent 设计："混合架构，fishing_component + devices" ✅
问题：架构合理，职责清晰
```

---

## 📚 文档更新对比

### 更新文档列表

| 文档 | 更新内容 | 更新幅度 |
|------|---------|---------|
| **MENTAL-MODEL-MIGRATION.md** | 🆕 新建 | 100%（新增） |
| **CAPABILITY-BOUNDARIES.md** | v2.0 更新 | 60%（新增章节、更新矩阵） |
| **README.md** | v2.0 更新 | 40%（更新总结、索引） |
| **architecture-library.md** | 新增章节 | 20%（新增原则章节） |
| **verseArchitectureSelector/SKILL.md** | v2.0 更新 | 30%（新增判定步骤） |
| **@ai-rules-templates.md** | 更新示例 | 15%（更新规则示例） |

### 保持不变的文档

以下技术详解文档保持不变（仍然有效）：
- ✅ 01-entity-component.md
- ✅ 02-event-system.md
- ✅ 03-async-mechanisms.md
- ✅ 04-data-structures.md
- ✅ 05-use-cases.md
- ✅ 06-limitations-faq.md
- ✅ 07-native-components.md

> **原因**: 这些文档描述的是 SceneGraph 的技术细节，与心智模型无关

---

## 🔄 迁移建议

### 对现有项目

1. **重新评审架构**：使用新模型的5项检查标准
2. **识别误用**：找出"不可 Component化却用了 SceneGraph"或反之的情况
3. **逐步重构**：优先重构核心模块，稳定模块可暂不动

### 对新项目

1. **需求分析阶段**：直接使用 Component化判定
2. **架构设计阶段**：使用决策流程图
3. **评审阶段**：使用架构评审检查清单（见 MENTAL-MODEL-MIGRATION.md）

---

## ✨ 总结

### 核心变化

从 **"功能分类"** 转变为 **"技术可行性判定"**

### 关键改进

1. ⭐ **决策标准清晰**: 5项检查 vs 模糊的功能分类
2. ⭐ **理论基础统一**: 对齐 SceneGraph 组件化本质
3. ⭐ **混合架构明确**: Component 持有状态，Device 提供能力
4. ⭐ **可验证可复现**: 技术判定 vs 主观判断

### 向前兼容

✅ 旧模型的所有技术内容保持有效  
✅ 只是决策框架和理解方式升级  
✅ 历史项目可逐步迁移，无需全部推翻

---

**文档负责人**: GitHub Copilot Agent  
**创建日期**: 2026-01-05  
**版本**: 1.0
