# 启动 Agent 替代方案调研报告

> **调研日期**: 2026-01-04
> **背景**: gh-aw 中 `create-agent-task` 和 `assignees: copilot` 存在 Bug，无法正常启动 Copilot Agent
> **目标**: 寻找不依赖 safe-outputs 的替代方案

---

## 问题回顾

### 已确认的 Bug

| Bug | 状态 | 详情 |
|-----|------|------|
| `create-agent-task` 环境变量不匹配 | 完全不工作 | lock.yml 设置 `GH_AW_*`，脚本读取 `GITHUB_AW_*` |
| `assignees: copilot` 不生效 | 双重 Bug | 编译器不传入配置 + Handler 不处理 assignees |
| `assign-to-agent` 不支持临时 ID | 边界限制 | 只接受真实 issue_number |

### 结论

**safe-outputs 的 Agent 相关功能目前不可用**，需要使用替代方案。

---

## ⚠️ 关键机制：GITHUB_TOKEN 防递归限制

### 问题

GitHub 为防止工作流无限递归，设计了一个**关键限制**：

> 使用默认 `GITHUB_TOKEN` 执行的任何操作（创建 Issue、添加标签、评论、Push 等）都**不会触发**后续 GitHub Actions 工作流。

### 影响范围

| 操作方式 | 使用的 Token | 是否触发后续 Action |
|----------|-------------|-------------------|
| **人工**操作（UI/CLI） | 用户凭证 | ✅ 触发 |
| **safe-outputs** | GITHUB_TOKEN（默认） | ❌ 不触发 |
| **tools.bash** + 默认 token | GITHUB_TOKEN（默认） | ❌ 不触发 |
| **tools.bash** + PAT | Personal Access Token | ✅ 触发 |

### 实际影响

```yaml
# ❌ 这样添加的标签不会触发后续 Agent
safe-outputs:
  create-issue:
    labels: [explorer-task]  # 使用 GITHUB_TOKEN，不触发

# ❌ 这样也不行
env:
  GITHUB_TOKEN: ${{ github.token }}  # 默认 token
# gh issue edit --add-label "explorer-task"  # 不触发

# ✅ 必须使用 PAT
env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}  # PAT
# gh issue edit --add-label "explorer-task"  # 触发！
```

### 解决方案

**所有需要触发后续工作流的操作，必须使用 PAT（Personal Access Token）**

```yaml
env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}  # PAT
```

### 官方文档

> "When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs."
>
> — [GitHub Actions 文档](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#using-the-github_token-in-a-workflow)

---

## 替代方案总览

| 方案 | 复杂度 | 可靠性 | 推荐场景 |
|------|--------|--------|----------|
| **方案 5: 标签驱动独立 Agent** | ⭐⭐ | ⭐⭐⭐⭐⭐ | **⭐ 首选方案** |
| 方案 1: tools.bash + gh api | ⭐⭐ | ⭐⭐⭐⭐⭐ | 单次任务创建 |
| 方案 2: tools.github + GraphQL | ⭐⭐⭐ | ⭐⭐⭐⭐ | 需要复杂逻辑时 |
| 方案 3: gh agent-task CLI | ⭐⭐ | ⭐⭐⭐ | 直接创建任务 |
| 方案 4: workflow_run 串联 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 多阶段流水线 |

---

## 方案 5: 标签驱动独立 Agent（⭐ 首选）

### 原理

每个 Agent 有独立的工作流文件，监听自己专属的标签。Planner 通过添加标签来调度任务。

### 架构图

```
Planner Agent 创建 Issue
        │
        ├── 分析任务类型
        ├── 添加对应标签 (explorer-task / builder-task / copilot-task)
        └── 完成
              │
              ▼
┌─────────────────────────────────────────────────────────────┐
│              GitHub Actions Event: issues.labeled           │
│                                                             │
│  ┌───────────────┐  ┌───────────────┐  ┌────────────────┐  │
│  │ explorer-task │  │ builder-task  │  │ copilot-task   │  │
│  └───────┬───────┘  └───────┬───────┘  └───────┬────────┘  │
│          ▼                  ▼                  ▼            │
│   explorer.md         builder.md      copilot-assigner.md  │
│   (gh-aw Agent)      (gh-aw Agent)    (分配给 Copilot)     │
└─────────────────────────────────────────────────────────────┘
```

### 标签体系

| 标签 | 用途 | 对应 Agent |
|------|------|------------|
| `explorer-task` | 探索/调研类任务 | explorer.md |
| `builder-task` | 构建/实现类任务 | builder.md |
| `integrator-task` | 集成/组装类任务 | integrator.md |
| `copilot-task` | 需要 Copilot 处理 | copilot-assigner.md |

### 工作流示例

#### 1. Explorer Agent (`explorer.md`)

```yaml
---
name: Explorer Agent
on:
  issues:
    types: [labeled]

permissions:
  contents: write
  issues: write
  pull-requests: write

tools:
  bash: ["gh *", "jq *", "curl *"]
  edit:

sandbox:
  agent: false
---

# Explorer Agent

## 触发条件

仅当标签为 `explorer-task` 时执行。

首先检查触发标签：
- 如果 `${{ github.event.label.name }}` 不是 `explorer-task`，立即停止，不做任何操作。

## 任务信息

- Issue: #${{ github.event.issue.number }}
- 标题: ${{ github.event.issue.title }}
- 仓库: ${{ github.repository }}

## 执行流程

1. 读取 Issue 内容获取任务描述
2. 执行探索/调研任务
3. 将结果写入 Issue 评论
4. 移除 `explorer-task` 标签，添加 `completed` 标签
```

#### 2. Builder Agent (`builder.md`)

```yaml
---
name: Builder Agent
on:
  issues:
    types: [labeled]

permissions:
  contents: write
  issues: write
  pull-requests: write

tools:
  bash: ["gh *", "jq *"]
  edit:

sandbox:
  agent: false
---

# Builder Agent

## 触发条件

仅当标签为 `builder-task` 时执行。

首先检查触发标签：
- 如果 `${{ github.event.label.name }}` 不是 `builder-task`，立即停止，不做任何操作。

## 任务信息

- Issue: #${{ github.event.issue.number }}
- 标题: ${{ github.event.issue.title }}

## 执行流程

1. 读取 Issue 内容获取任务描述
2. 执行构建/实现任务
3. 创建 PR 或提交代码
4. 移除 `builder-task` 标签，添加 `completed` 标签
```

#### 3. Copilot Assigner (`copilot-assigner.md`)

```yaml
---
name: Copilot Assigner
on:
  issues:
    types: [labeled]

permissions:
  contents: read
  issues: write
  pull-requests: write

tools:
  bash: ["gh api *", "gh issue *", "jq *"]

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
---

# Copilot 任务分配器

## 触发条件

仅当标签为 `copilot-task` 时执行。

首先检查触发标签：
- 如果 `${{ github.event.label.name }}` 不是 `copilot-task`，立即停止。

## 分配给 Copilot

使用 REST API 将 Issue 分配给 Copilot Agent：

\`\`\`bash
gh api \
  --method PATCH \
  -H "Accept: application/vnd.github+json" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  /repos/${{ github.repository }}/issues/${{ github.event.issue.number }} \
  --input - <<< '{
    "assignees": ["copilot-swe-agent[bot]"],
    "agent_assignment": {
      "target_repo": "${{ github.repository }}",
      "base_branch": "main"
    }
  }'
\`\`\`

## 完成后

移除 `copilot-task` 标签，添加 `copilot-assigned` 标签。
```

#### 4. Planner Agent (`planner.md`)

```yaml
---
name: Planner Agent
on:
  workflow_dispatch:
    inputs:
      task_description:
        description: '任务描述'
        required: true
        type: string

permissions:
  contents: read
  issues: write

tools:
  bash: ["gh issue *", "gh label *"]
  edit:

safe-outputs:
  create-issue:
    labels: []
    max: 5
---

# Planner Agent

## 任务

分析输入的任务描述，决定分配给哪个 Agent。

## 分析逻辑

根据任务类型选择标签：
- **探索/调研类**（分析、查找、调研）→ `explorer-task`
- **构建/实现类**（编写代码、创建文件）→ `builder-task`
- **集成/组装类**（整合、连接）→ `integrator-task`
- **复杂编码任务**（需要深度理解代码库）→ `copilot-task`

## 执行

1. 分析任务：${{ github.event.inputs.task_description }}
2. 创建 Issue 并添加对应的 Agent 标签
3. 使用 `gh issue create` 创建 Issue
4. 使用 `gh issue edit --add-label <agent>-task` 添加标签
```

### Planner 添加标签触发 Agent 的关键

**重要**：使用 `GITHUB_TOKEN` 添加标签**不会触发**后续工作流（GitHub 防递归机制）。

**解决方案**：Planner 需要使用 PAT 来添加标签。

```yaml
env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}  # PAT，非默认 token
```

或者在创建 Issue 时直接带上标签：

```bash
gh issue create \
  --title "任务标题" \
  --body "任务描述" \
  --label "explorer-task"
```

### 优势

1. **职责清晰**：每个 Agent 独立工作流，易于维护
2. **松耦合**：Planner 只负责分配，不关心 Agent 实现
3. **可扩展**：新增 Agent 只需添加标签和工作流
4. **原生支持**：利用 GitHub Actions 内置事件，无需 safe-outputs
5. **可观测**：通过标签可直观看到任务状态

### 注意事项

1. **PAT 要求**：Planner 添加标签必须使用 PAT 才能触发后续 Agent
2. **标签检查**：每个 Agent 工作流开头必须检查标签名
3. **防重复**：Agent 完成后应移除触发标签

---

## 方案 1: tools.bash + gh api

### 原理

在 gh-aw 工作流中，使用 `tools.bash` 直接调用 GitHub CLI API，绕过 safe-outputs。

### 配置示例

```yaml
---
on:
  workflow_dispatch:
    inputs:
      task_description:
        description: '任务描述'
        required: true
        type: string

permissions:
  contents: read
  issues: write
  pull-requests: write

tools:
  bash: ["gh api *", "gh issue *", "jq *"]
  edit:

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}  # 需要 PAT

# 注意：不使用 safe-outputs
---

# Copilot Agent 任务创建器

## 任务
根据用户输入创建 Issue 并分配给 Copilot Agent。

## 执行步骤

1. **创建 Issue 并分配给 Copilot**

使用以下命令创建 Issue 并分配给 Copilot：

\`\`\`bash
gh api \
  --method POST \
  -H "Accept: application/vnd.github+json" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  /repos/${{ github.repository }}/issues \
  --input - <<< '{
  "title": "[Agent Task] ${{ github.event.inputs.task_description }}",
  "body": "${{ github.event.inputs.task_description }}",
  "assignees": ["copilot-swe-agent[bot]"],
  "agent_assignment": {
    "target_repo": "${{ github.repository }}",
    "base_branch": "main",
    "custom_instructions": "",
    "custom_agent": "",
    "model": ""
  }
}'
\`\`\`

2. **确认结果**

检查返回的 JSON 确认 Issue 创建成功。
```

### 关键要点

1. **必须使用 PAT**：`GITHUB_TOKEN` 无法分配 Copilot
2. **直接调用 REST API**：绕过所有 safe-outputs 限制
3. **assignee 格式**：使用 `copilot-swe-agent[bot]`（带 `[bot]` 后缀）

### REST API 参数说明

| 参数 | 必需 | 说明 |
|------|------|------|
| `assignees` | ✅ | `["copilot-swe-agent[bot]"]` |
| `agent_assignment.target_repo` | ✅ | 工作仓库 |
| `agent_assignment.base_branch` | ✅ | 基础分支 |
| `agent_assignment.custom_instructions` | ❌ | 额外指令 |
| `agent_assignment.custom_agent` | ❌ | 自定义 Agent |
| `agent_assignment.model` | ❌ | 使用的模型 |

---

## 方案 2: tools.github + GraphQL

### 适用场景

需要更复杂的逻辑（如先查询仓库 ID、验证 Copilot 可用性）。

### 配置示例

```yaml
---
on:
  issues:
    types: [labeled]

permissions:
  contents: read
  issues: write

tools:
  github:
    toolsets: [issues, repos]
  bash: ["gh api *"]

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
---

# Issue 转 Copilot 任务

当 Issue 被添加 `copilot-task` 标签时，将其分配给 Copilot。

## 步骤

1. **获取 Copilot Bot ID**

\`\`\`bash
gh api graphql -f query='query {
  repository(owner: "${{ github.repository_owner }}", name: "${{ github.event.repository.name }}") {
    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
      nodes {
        login
        __typename
        ... on Bot {
          id
        }
      }
    }
  }
}'
\`\`\`

查找 `login` 为 `copilot-swe-agent` 的节点，记录其 `id`。

2. **分配 Issue 给 Copilot**

\`\`\`bash
gh api graphql -f query='mutation {
  addAssigneesToAssignable(input: {
    assignableId: "ISSUE_GLOBAL_ID",
    assigneeIds: ["COPILOT_BOT_ID"],
    agentAssignment: {
      targetRepositoryId: "REPOSITORY_ID",
      baseRef: "main"
    }
  }) {
    assignable {
      ... on Issue {
        id
        assignees(first: 5) {
          nodes { login }
        }
      }
    }
  }
}' -H 'GraphQL-Features: issues_copilot_assignment_api_support,coding_agent_model_selection'
\`\`\`
```

### GraphQL Mutations 速查

| Mutation | 用途 |
|----------|------|
| `createIssue` | 创建新 Issue 并分配 |
| `updateIssue` | 更新现有 Issue 的 assignees |
| `addAssigneesToAssignable` | 添加 assignee（保留现有） |
| `replaceActorsForAssignable` | 替换所有 assignees |

### 必需的 GraphQL Header

```bash
-H 'GraphQL-Features: issues_copilot_assignment_api_support,coding_agent_model_selection'
```

---

## 方案 3: gh agent-task CLI

### 适用场景

直接创建 Copilot Agent 任务，跳过 Issue 创建步骤。

### 安装

```bash
gh extension install github/agent-task
```

### 使用

```yaml
---
on: workflow_dispatch

tools:
  bash: ["gh agent-task *"]

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
---

# 创建 Agent 任务

\`\`\`bash
gh agent-task create "实现用户认证功能的单元测试" --base main
\`\`\`
```

### 命令参数

| 参数 | 说明 |
|------|------|
| `--base <branch>` | PR 基础分支 |
| `--repo <owner/repo>` | 目标仓库 |
| `--from-file <path>` | 从文件读取任务描述 |

### 注意事项

- 需要 `COPILOT_GITHUB_TOKEN` 或 `GH_AW_GITHUB_TOKEN`
- 默认 `GITHUB_TOKEN` 权限不足

---

## 方案 4: workflow_run 串联

### 适用场景

多阶段流水线，第一阶段创建 Issue，第二阶段触发 Copilot 处理。

### 架构

```
Workflow A (创建 Issue)
    │
    ├── 创建 Issue（不分配 Copilot）
    ├── 添加标签 `copilot-pending`
    └── 完成
          │
          ▼
Workflow B (on: workflow_run)
    │
    ├── 查找 `copilot-pending` 标签的 Issue
    ├── 使用 gh api 分配给 Copilot
    └── 移除 `copilot-pending` 标签
```

### Workflow A (创建 Issue)

```yaml
---
on: workflow_dispatch

permissions:
  issues: write

safe-outputs:
  create-issue:
    labels: [copilot-pending]
    max: 1
---

创建一个 Issue 描述任务，添加 `copilot-pending` 标签。
```

### Workflow B (分配 Copilot)

```yaml
---
on:
  workflow_run:
    workflows: ["Workflow A"]
    types: [completed]

permissions:
  issues: write

tools:
  bash: ["gh issue *", "gh api *"]

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
---

# Copilot 任务分配器

1. 查找带有 `copilot-pending` 标签的 Issue
2. 分配给 Copilot
3. 移除 `copilot-pending` 标签
```

### 优势

- Workflow A 可以使用 safe-outputs（虽然不完美，但创建 Issue 是可行的）
- Workflow B 专门处理 Copilot 分配，使用 PAT
- 职责分离，易于调试

---

## Token 配置指南

### 创建 PAT

1. 访问 GitHub Settings → Developer settings → Personal access tokens → Fine-grained tokens
2. 选择目标仓库
3. 权限配置：
   - **Actions**: Read and write
   - **Contents**: Read and write
   - **Issues**: Read and write
   - **Pull requests**: Read and write

### 配置 Secret

```bash
# 在仓库 Settings → Secrets and variables → Actions
# 添加 COPILOT_GITHUB_TOKEN
```

### 在工作流中使用

```yaml
env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
```

---

## 验证 Copilot 可用性

在分配任务前，可以先验证仓库是否启用了 Copilot：

```bash
gh api graphql -f query='query {
  repository(owner: "OWNER", name: "REPO") {
    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
      nodes {
        login
        __typename
      }
    }
  }
}'
```

如果返回结果中包含 `login: "copilot-swe-agent"`，则 Copilot 已启用。

---

## 最佳实践

### 1. 任务描述格式

```markdown
# 任务标题

## 目标
清晰描述要实现的功能

## 文件范围
- `src/auth/login.js` - 需要重构
- `tests/auth.test.js` - 需要添加测试

## 验收标准
1. 所有测试通过
2. 代码覆盖率 > 80%

## 约束
- 保持 API 向后兼容
- 使用现有的 ErrorHandler 类
```

### 2. 错误处理

```bash
RESULT=$(gh api ... 2>&1)
if echo "$RESULT" | jq -e '.id' > /dev/null 2>&1; then
  echo "Issue 创建成功: $(echo $RESULT | jq -r '.html_url')"
else
  echo "错误: $RESULT"
  exit 1
fi
```

### 3. 避免重复分配

分配前检查 Issue 是否已有 Copilot assignee：

```bash
ASSIGNEES=$(gh issue view $ISSUE_NUMBER --json assignees -q '.assignees[].login')
if echo "$ASSIGNEES" | grep -q "copilot"; then
  echo "Issue 已分配给 Copilot"
  exit 0
fi
```

---

## 总结

| 场景 | 推荐方案 |
|------|----------|
| 多 Agent 调度系统 | **方案 5**: 标签驱动独立 Agent |
| 简单创建任务 | 方案 1: tools.bash + gh api REST |
| 需要查询/验证 | 方案 2: GraphQL |
| 纯命令行使用 | 方案 3: gh agent-task |
| 多阶段流水线 | 方案 4: workflow_run |

**核心要点**：

1. **标签驱动**：Planner 添加标签触发对应 Agent
2. 使用 PAT（`COPILOT_GITHUB_TOKEN`）而非默认 `GITHUB_TOKEN`
3. 每个 Agent 独立工作流，监听专属标签
4. assignee 格式为 `copilot-swe-agent[bot]`
5. REST API 需要 `agent_assignment` 对象

---

## 相关文档

- [CAPABILITY-BOUNDARIES.md](../CAPABILITY-BOUNDARIES.md) - 能力边界文档
- [FAILURE-CASES.md](../FAILURE-CASES.md) - 失败案例记录
- [GitHub Copilot 官方文档](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-a-pr)
