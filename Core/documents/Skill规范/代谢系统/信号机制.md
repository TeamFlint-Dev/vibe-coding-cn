# 信号机制

信号是代谢系统的核心数据单元，连接行为痕迹与代谢动作。

## 信号的本质

> **信号 = 归因后的问题描述**

信号不是原始日志，而是经过归因和分类的问题记录：
- **归因**：指向具体的 Skill 节点
- **分类**：标识问题类型
- **证据**：保留原始痕迹的引用

## 信号格式

### 基本结构

```yaml
target: verseDev/verseComponent     # 归因的 Skill 路径
type: outdated                       # 问题类型
count: 3                             # 累积次数
evidences:                           # 证据列表
  - source: actions/run-12345
    description: "示例代码在 UEFN 5.x 无法编译"
    timestamp: 2026-01-02
  - source: actions/run-12346
    description: "组件模板缺少新 API"
    timestamp: 2026-01-02
```

### 使用 GitHub Issues 作为信号池

每个信号对应一个 GitHub Issue：

| Issue 字段 | 信号含义 |
|-----------|---------|
| Title | `[{type}] {target}` |
| Labels | 信号类型标签 |
| Body | evidences 列表 |
| Comments | 新增 evidence 时追加 |
| State | open = 待处理，closed = 已处理 |

**示例 Issue**:

```markdown
Title: [outdated] verseDev/verseComponent
Labels: signal, outdated
Body:
## 信号记录

**Target**: verseDev/verseComponent
**Type**: outdated
**Count**: 3

### Evidences

1. **2026-01-02** via actions/run-12345
   示例代码在 UEFN 5.x 无法编译

2. **2026-01-02** via actions/run-12346
   组件模板缺少新 API

3. **2026-01-03** via actions/run-12350
   参考的 Fortnite API 已废弃
```

## 信号类型

### 核心类型

| 类型 | 含义 | 触发的代谢动作 |
|------|------|---------------|
| `outdated` | 内容过时 | 更新 |
| `unclear` | 边界模糊（选择困难） | 锐化 |
| `missing` | 能力缺失 | 生长/新建 |
| `conflict` | 与其他 Skill 冲突/重叠 | 合并或划界 |
| `overload` | 职责过多 | 拆分 |
| `unused` | 长期未使用 | 遗忘/废弃 |
| `friction` | 使用有阻力（通用） | 待分析 |

### 类型是半开放的

核心类型覆盖常见情况，但审计者可以创建新类型：
- 新类型用 `friction-*` 前缀
- 累积足够案例后，可升级为核心类型

```
friction-api-mismatch → 发现是常见问题 → 升级为 api-mismatch
```

## 信号产生

### 双通道产生

```
┌─────────────────────────────────────────────────────────────────┐
│                         信号产生双通道                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  通道 1：创建者主动发送（实时）                                  │
│  ─────────────────────────────                                  │
│                                                                 │
│  创建者执行任务                                                  │
│      ↓ 遇到阻力                                                 │
│      ↓ 分析根因                                                 │
│      ↓ 创建 Issue：{target, type, evidence}                     │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  通道 2：审计者被动提取（批量）                                  │
│  ─────────────────────────────                                  │
│                                                                 │
│  审计者读取 GitHub Actions 日志                                  │
│      ↓ 识别失败/回退/犹豫模式                                    │
│      ↓ 归因到具体 Skill                                         │
│      ↓ 创建或更新 Issue                                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 创建者发送信号的时机

创建者应在以下情况主动发送信号：

```markdown
## 明确的阻力情况

- [ ] 找不到合适的 Skill 处理当前需求 → `missing`
- [ ] Skill 描述与实际内容不符 → `unclear`
- [ ] 示例代码无法运行 → `outdated`
- [ ] 需要同时参考多个重叠的 Skill → `conflict`
- [ ] 一个 Skill 内容过多，难以定位 → `overload`

## 可选的阻力情况

- [ ] 完成任务但过程不顺畅 → `friction`
- [ ] 发现更好的实现方式 → `friction-improvement`
```

## 信号合并

### 合并规则

相同 `target + type` 的信号应合并：

```
新信号到达
    │
    ▼
检查是否存在相同 target+type 的 open Issue
    │
    ├─ 存在 → 追加 evidence 到 Comments，count +1
    │
    └─ 不存在 → 创建新 Issue
```

### 合并的意义

合并确保信号池大小有界：

```
信号池最大规模 ≤ Skill 数量 × 信号类型数量
```

这避免了信号无序扩张。

## 信号消费

### 阈值触发

当信号满足触发条件时，调度重构者：

| 信号类型 | 触发阈值 | 说明 |
|----------|----------|------|
| `outdated` | count ≥ 2 | 2 次过时报告就该更新 |
| `unclear` | count ≥ 3 | 3 次选择困难说明边界确实模糊 |
| `missing` | count ≥ 3 | 3 次找不到说明确实需要新建 |
| `conflict` | count ≥ 2 | 2 次冲突就该处理 |
| `overload` | count ≥ 2 | 2 次过载就该拆分 |
| `unused` | 30 天无使用 | 持续未使用考虑废弃 |
| `friction` | count ≥ 5 | 通用阻力需要更多案例才能判断 |

### 信号关闭

重构完成后：
1. 在 Issue 中记录重构动作
2. 关闭 Issue
3. 如果问题再次出现，会创建新 Issue

## 信号查询

### 按 Skill 查询

```bash
gh issue list --label "signal" --search "verseDev/verseComponent in:title"
```

### 按类型查询

```bash
gh issue list --label "signal,outdated"
```

### 查询待处理信号

```bash
gh issue list --label "signal" --state open
```

## 人工参与

信号池使用 GitHub Issues 的另一个好处是**人可以参与**：

- 人可以直接创建信号 Issue
- 人可以调整信号优先级
- 人可以关闭误报的信号
- 人可以在 Issue 中讨论解决方案

这让代谢系统不是完全自动化的黑盒，而是人机协作的开放系统。

---

**相关文档**：
- [代谢主体](代谢主体.md)
- [代谢动作](代谢动作.md)
- [调度规则](调度规则.md)
