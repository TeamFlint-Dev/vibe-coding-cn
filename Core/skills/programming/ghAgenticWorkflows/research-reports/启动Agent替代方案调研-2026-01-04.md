# 启动 Agent 替代方案调研报告

> **调研日期**: 2026-01-04
> **背景**: gh-aw 中 `create-agent-task` 和 `assignees: copilot` 存在 Bug，无法正常启动 Copilot Agent
> **目标**: 寻找不依赖 safe-outputs 的替代方案

---

## 问题回顾

### 已确认的 Bug

| Bug | 状态 | 详情 |
|-----|------|------|
| `create-agent-task` 环境变量不匹配 | 完全不工作 | lock.yml 设置 `GH_AW_*`，脚本读取 `GITHUB_AW_*` |
| `assignees: copilot` 不生效 | 双重 Bug | 编译器不传入配置 + Handler 不处理 assignees |
| `assign-to-agent` 不支持临时 ID | 边界限制 | 只接受真实 issue_number |

### 结论

**safe-outputs 的 Agent 相关功能目前不可用**，需要使用替代方案。

---

## 替代方案总览

| 方案 | 复杂度 | 可靠性 | 推荐场景 |
|------|--------|--------|----------|
| **方案 1: tools.bash + gh api** | ⭐⭐ | ⭐⭐⭐⭐⭐ | **首选方案** |
| 方案 2: tools.github + GraphQL | ⭐⭐⭐ | ⭐⭐⭐⭐ | 需要复杂逻辑时 |
| 方案 3: gh agent-task CLI | ⭐⭐ | ⭐⭐⭐ | 直接创建任务 |
| 方案 4: workflow_run 串联 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 多阶段流水线 |

---

## 方案 1: tools.bash + gh api（⭐ 首选）

### 原理

在 gh-aw 工作流中，使用 `tools.bash` 直接调用 GitHub CLI API，绕过 safe-outputs。

### 配置示例

```yaml
---
on:
  workflow_dispatch:
    inputs:
      task_description:
        description: '任务描述'
        required: true
        type: string

permissions:
  contents: read
  issues: write
  pull-requests: write

tools:
  bash: ["gh api *", "gh issue *", "jq *"]
  edit:

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}  # 需要 PAT

# 注意：不使用 safe-outputs
---

# Copilot Agent 任务创建器

## 任务
根据用户输入创建 Issue 并分配给 Copilot Agent。

## 执行步骤

1. **创建 Issue 并分配给 Copilot**

使用以下命令创建 Issue 并分配给 Copilot：

\`\`\`bash
gh api \
  --method POST \
  -H "Accept: application/vnd.github+json" \
  -H "X-GitHub-Api-Version: 2022-11-28" \
  /repos/${{ github.repository }}/issues \
  --input - <<< '{
  "title": "[Agent Task] ${{ github.event.inputs.task_description }}",
  "body": "${{ github.event.inputs.task_description }}",
  "assignees": ["copilot-swe-agent[bot]"],
  "agent_assignment": {
    "target_repo": "${{ github.repository }}",
    "base_branch": "main",
    "custom_instructions": "",
    "custom_agent": "",
    "model": ""
  }
}'
\`\`\`

2. **确认结果**

检查返回的 JSON 确认 Issue 创建成功。
```

### 关键要点

1. **必须使用 PAT**：`GITHUB_TOKEN` 无法分配 Copilot
2. **直接调用 REST API**：绕过所有 safe-outputs 限制
3. **assignee 格式**：使用 `copilot-swe-agent[bot]`（带 `[bot]` 后缀）

### REST API 参数说明

| 参数 | 必需 | 说明 |
|------|------|------|
| `assignees` | ✅ | `["copilot-swe-agent[bot]"]` |
| `agent_assignment.target_repo` | ✅ | 工作仓库 |
| `agent_assignment.base_branch` | ✅ | 基础分支 |
| `agent_assignment.custom_instructions` | ❌ | 额外指令 |
| `agent_assignment.custom_agent` | ❌ | 自定义 Agent |
| `agent_assignment.model` | ❌ | 使用的模型 |

---

## 方案 2: tools.github + GraphQL

### 适用场景

需要更复杂的逻辑（如先查询仓库 ID、验证 Copilot 可用性）。

### 配置示例

```yaml
---
on:
  issues:
    types: [labeled]

permissions:
  contents: read
  issues: write

tools:
  github:
    toolsets: [issues, repos]
  bash: ["gh api *"]

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
---

# Issue 转 Copilot 任务

当 Issue 被添加 `copilot-task` 标签时，将其分配给 Copilot。

## 步骤

1. **获取 Copilot Bot ID**

\`\`\`bash
gh api graphql -f query='query {
  repository(owner: "${{ github.repository_owner }}", name: "${{ github.event.repository.name }}") {
    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
      nodes {
        login
        __typename
        ... on Bot {
          id
        }
      }
    }
  }
}'
\`\`\`

查找 `login` 为 `copilot-swe-agent` 的节点，记录其 `id`。

2. **分配 Issue 给 Copilot**

\`\`\`bash
gh api graphql -f query='mutation {
  addAssigneesToAssignable(input: {
    assignableId: "ISSUE_GLOBAL_ID",
    assigneeIds: ["COPILOT_BOT_ID"],
    agentAssignment: {
      targetRepositoryId: "REPOSITORY_ID",
      baseRef: "main"
    }
  }) {
    assignable {
      ... on Issue {
        id
        assignees(first: 5) {
          nodes { login }
        }
      }
    }
  }
}' -H 'GraphQL-Features: issues_copilot_assignment_api_support,coding_agent_model_selection'
\`\`\`
```

### GraphQL Mutations 速查

| Mutation | 用途 |
|----------|------|
| `createIssue` | 创建新 Issue 并分配 |
| `updateIssue` | 更新现有 Issue 的 assignees |
| `addAssigneesToAssignable` | 添加 assignee（保留现有） |
| `replaceActorsForAssignable` | 替换所有 assignees |

### 必需的 GraphQL Header

```bash
-H 'GraphQL-Features: issues_copilot_assignment_api_support,coding_agent_model_selection'
```

---

## 方案 3: gh agent-task CLI

### 适用场景

直接创建 Copilot Agent 任务，跳过 Issue 创建步骤。

### 安装

```bash
gh extension install github/agent-task
```

### 使用

```yaml
---
on: workflow_dispatch

tools:
  bash: ["gh agent-task *"]

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
---

# 创建 Agent 任务

\`\`\`bash
gh agent-task create "实现用户认证功能的单元测试" --base main
\`\`\`
```

### 命令参数

| 参数 | 说明 |
|------|------|
| `--base <branch>` | PR 基础分支 |
| `--repo <owner/repo>` | 目标仓库 |
| `--from-file <path>` | 从文件读取任务描述 |

### 注意事项

- 需要 `COPILOT_GITHUB_TOKEN` 或 `GH_AW_GITHUB_TOKEN`
- 默认 `GITHUB_TOKEN` 权限不足

---

## 方案 4: workflow_run 串联

### 适用场景

多阶段流水线，第一阶段创建 Issue，第二阶段触发 Copilot 处理。

### 架构

```
Workflow A (创建 Issue)
    │
    ├── 创建 Issue（不分配 Copilot）
    ├── 添加标签 `copilot-pending`
    └── 完成
          │
          ▼
Workflow B (on: workflow_run)
    │
    ├── 查找 `copilot-pending` 标签的 Issue
    ├── 使用 gh api 分配给 Copilot
    └── 移除 `copilot-pending` 标签
```

### Workflow A (创建 Issue)

```yaml
---
on: workflow_dispatch

permissions:
  issues: write

safe-outputs:
  create-issue:
    labels: [copilot-pending]
    max: 1
---

创建一个 Issue 描述任务，添加 `copilot-pending` 标签。
```

### Workflow B (分配 Copilot)

```yaml
---
on:
  workflow_run:
    workflows: ["Workflow A"]
    types: [completed]

permissions:
  issues: write

tools:
  bash: ["gh issue *", "gh api *"]

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
---

# Copilot 任务分配器

1. 查找带有 `copilot-pending` 标签的 Issue
2. 分配给 Copilot
3. 移除 `copilot-pending` 标签
```

### 优势

- Workflow A 可以使用 safe-outputs（虽然不完美，但创建 Issue 是可行的）
- Workflow B 专门处理 Copilot 分配，使用 PAT
- 职责分离，易于调试

---

## Token 配置指南

### 创建 PAT

1. 访问 GitHub Settings → Developer settings → Personal access tokens → Fine-grained tokens
2. 选择目标仓库
3. 权限配置：
   - **Actions**: Read and write
   - **Contents**: Read and write
   - **Issues**: Read and write
   - **Pull requests**: Read and write

### 配置 Secret

```bash
# 在仓库 Settings → Secrets and variables → Actions
# 添加 COPILOT_GITHUB_TOKEN
```

### 在工作流中使用

```yaml
env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
```

---

## 验证 Copilot 可用性

在分配任务前，可以先验证仓库是否启用了 Copilot：

```bash
gh api graphql -f query='query {
  repository(owner: "OWNER", name: "REPO") {
    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
      nodes {
        login
        __typename
      }
    }
  }
}'
```

如果返回结果中包含 `login: "copilot-swe-agent"`，则 Copilot 已启用。

---

## 最佳实践

### 1. 任务描述格式

```markdown
# 任务标题

## 目标
清晰描述要实现的功能

## 文件范围
- `src/auth/login.js` - 需要重构
- `tests/auth.test.js` - 需要添加测试

## 验收标准
1. 所有测试通过
2. 代码覆盖率 > 80%

## 约束
- 保持 API 向后兼容
- 使用现有的 ErrorHandler 类
```

### 2. 错误处理

```bash
RESULT=$(gh api ... 2>&1)
if echo "$RESULT" | jq -e '.id' > /dev/null 2>&1; then
  echo "Issue 创建成功: $(echo $RESULT | jq -r '.html_url')"
else
  echo "错误: $RESULT"
  exit 1
fi
```

### 3. 避免重复分配

分配前检查 Issue 是否已有 Copilot assignee：

```bash
ASSIGNEES=$(gh issue view $ISSUE_NUMBER --json assignees -q '.assignees[].login')
if echo "$ASSIGNEES" | grep -q "copilot"; then
  echo "Issue 已分配给 Copilot"
  exit 0
fi
```

---

## 总结

| 场景 | 推荐方案 |
|------|----------|
| 简单创建任务 | **方案 1**: tools.bash + gh api REST |
| 需要查询/验证 | 方案 2: GraphQL |
| 纯命令行使用 | 方案 3: gh agent-task |
| 多阶段流水线 | 方案 4: workflow_run |

**核心要点**：
1. 绕过 safe-outputs，直接使用 `tools.bash` 调用 API
2. 使用 PAT（`COPILOT_GITHUB_TOKEN`）而非默认 `GITHUB_TOKEN`
3. assignee 格式为 `copilot-swe-agent[bot]`
4. REST API 需要 `agent_assignment` 对象

---

## 相关文档

- [CAPABILITY-BOUNDARIES.md](../CAPABILITY-BOUNDARIES.md) - 能力边界文档
- [FAILURE-CASES.md](../FAILURE-CASES.md) - 失败案例记录
- [GitHub Copilot 官方文档](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-a-pr)
