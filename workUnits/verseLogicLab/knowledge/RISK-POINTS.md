# Risk Points Documentation
# 风险点记录文档

> **目的**: 记录和追踪代码库中已识别的风险点、潜在问题和语言限制，确保所有类似风险被暴露和管理。

---

## 📋 风险点分类

### 1. 语言限制风险（Language Limitation Risks）

#### RISK-001: 递归导致的堆栈溢出风险 ⚠️ 已解决
- **风险等级**: 🔴 高危
- **状态**: ✅ 已缓解 (ADR-008)
- **描述**: 递归函数在极端输入下可能导致堆栈溢出
- **影响范围**: 所有使用递归的函数
- **发现时间**: 2026-01-13
- **解决方案**: 
  - 禁止所有递归，强制使用 for 循环
  - 设置最大迭代次数限制
  - 使用 `<transacts>` 效果支持 var
- **相关决策**: ADR-008
- **相关代码**: `MathRanges.verse` (已重构)
- **验证方法**: Code Review 严格检查，编译器无法检测

#### RISK-002: Verse 不支持字符级别操作
- **风险等级**: 🟡 中危
- **状态**: ⚠️ 已知限制
- **描述**: Verse 没有 `char.ToInt` 方法，无法进行字符级别的验证
- **影响范围**: 字符串验证功能
- **发现时间**: 2026-01-13
- **当前缓解**: 
  - TASK-082 简化为仅长度验证
  - 字母数字验证功能暂缓
- **未来解决**: 等待 Verse API 更新或使用替代方法
- **相关代码**: `StringValidation.verse`
- **影响任务**: TASK-082 (部分功能缺失)

#### RISK-003: vector3 不暴露分量访问
- **风险等级**: 🟡 中危
- **状态**: ⚠️ 已知限制
- **描述**: vector3 类型不提供 .X, .Y, .Z 成员访问
- **影响范围**: 向量验证和分量操作
- **发现时间**: 2026-01-13
- **当前缓解**: 
  - TASK-084 (Vector Validation) 暂缓
  - 无法实现分量级别的验证
- **未来解决**: 等待 Verse API 研究或使用 Verse 内置函数
- **相关代码**: 无 (未实现)
- **影响任务**: TASK-084 (完全阻塞)

#### RISK-004: 模块级别不支持 private 访问修饰符
- **风险等级**: 🟢 低危
- **状态**: ⚠️ 已知限制
- **描述**: Verse 模块中只允许 `<public>` 访问级别，`<private>` 仅在类中可用
- **影响范围**: 辅助函数无法隐藏
- **发现时间**: 2026-01-13
- **当前缓解**: 
  - 所有辅助函数改为 public
  - 通过命名约定区分内部函数（未实施）
- **未来解决**: 考虑使用类封装或接受限制
- **相关代码**: `StringValidation.verse` (尝试失败)
- **影响任务**: TASK-082 (轻微影响代码组织)

---

### 2. 性能风险（Performance Risks）

#### RISK-005: 数组唯一性检查的 O(n²) 复杂度
- **风险等级**: 🟡 中危
- **状态**: ⚠️ 已知但可接受
- **描述**: `ValidateNoDuplicateInts` 和 `ValidateNoDuplicateStrings` 使用嵌套循环，时间复杂度 O(n²)
- **影响范围**: 大数组（>1000 元素）的唯一性验证
- **发现时间**: 2026-01-13
- **当前缓解**: 
  - 在文档中明确标注复杂度警告
  - 建议仅用于小到中等数组
- **未来解决**: 
  - 研究 Verse 是否支持 Set/Map 数据结构
  - 考虑排序后去重的 O(n log n) 方案
- **相关代码**: `ArrayValidation.verse` - ValidateNoDuplicateInts, ValidateNoDuplicateStrings
- **影响任务**: TASK-083 (性能限制)
- **⚖️ 精度与性能平衡**:
  - **精度考虑**: O(n²) 算法保证 100% 准确检测重复（不会漏检或误检）
  - **性能考虑**: 
    - n=10: ~100 次比较（可忽略）
    - n=100: ~10,000 次比较（可接受）
    - n=1000: ~1,000,000 次比较（可能卡顿）
  - **平衡策略**: 在代码注释中明确标注"大数组慎用"，建议 n < 500
  - **性能影响**: 简单整数/字符串比较，单次比较快，但总量随 n² 增长
  - **替代方案权衡**: 排序方案 O(n log n) 更快，但需要额外内存且破坏原始顺序

#### RISK-006: 迭代循环的最大次数限制
- **风险等级**: 🟡 中危
- **状态**: ⚠️ 需要监控
- **描述**: 所有迭代循环都设置了固定的最大迭代次数（如100次），极端输入可能不够
- **影响范围**: 所有使用 for 循环的迭代函数
- **发现时间**: 2026-01-13
- **当前缓解**: 
  - 选择足够大的迭代次数（100次对大多数情况够用）
  - 在代码注释中说明限制
- **未来解决**: 
  - 根据实际使用情况调整迭代次数
  - 添加溢出检测和日志
- **相关代码**: `MathRanges.verse` - NormalizeAngle360
- **影响任务**: 所有使用迭代的任务
- **⚖️ 精度与性能平衡**:
  - **精度考虑**: 100次迭代覆盖角度范围 [-36000°, +36000°]，足够处理 99.9% 实际场景
  - **性能考虑**: 固定上限防止无限循环，最坏情况下 100 次循环耗时可控（微秒级）
  - **平衡策略**: 
    - 常见情况（-360° ~ +720°）：1-2次迭代即可
    - 极端情况（±10000°）：27-28次迭代
    - 病态输入（±1e10）：达到100次上限，结果可能不精确但不会崩溃
  - **性能影响**: 每次迭代仅做简单加减法，性能开销极小
  - **安全优先**: 宁可牺牲极端输入的精度，也要保证不会堆栈溢出或无限循环

---

### 3. 类型安全风险（Type Safety Risks）

#### RISK-007: 浮点数精度问题
- **风险等级**: 🟡 中危
- **状态**: ✅ 已缓解
- **描述**: 直接比较浮点数可能因精度问题导致错误结果
- **影响范围**: 所有浮点数比较操作
- **发现时间**: 2026-01-13 (规划阶段)
- **当前缓解**: 
  - 统一使用 epsilon 容差 (0.0001)
  - 所有浮点验证函数支持自定义 epsilon
  - 与 MathFloatComparison 保持一致
- **未来解决**: 已解决
- **相关代码**: `RangeValidation.verse`, `ArrayValidation.verse`
- **影响任务**: TASK-081, TASK-083
- **相关决策**: ADR-007
- **⚖️ 精度与性能平衡**:
  - **精度考虑**: epsilon = 0.0001 提供足够精度用于大多数游戏场景（位置、角度、百分比）
  - **性能考虑**: 避免使用更复杂的精度控制（如相对误差），保持简单快速的比较
  - **平衡策略**: 默认值适用于 99% 场景，允许自定义 epsilon 处理特殊需求
  - **性能影响**: 浮点比较为 O(1)，性能开销可忽略
  - **用户建议**: 如需更高精度，传入更小的 epsilon（如 1e-6）；如需更快速度，传入更大的 epsilon（如 0.01）

#### RISK-008: 效果系统使用不当
- **风险等级**: 🟡 中危
- **状态**: ⚠️ 需要持续监控
- **描述**: 
  - `<computes>` 不允许使用 var
  - `<decides>` 必须配合方括号调用
  - 效果组合规则复杂
- **影响范围**: 所有函数定义
- **发现时间**: 2026-01-13
- **当前缓解**: 
  - 建立效果使用模式 (PATTERNS.md)
  - 验证函数统一使用 `<decides><transacts>:void`
  - 迭代函数使用 `<transacts>` 支持 var
- **未来解决**: 持续学习和文档化
- **相关代码**: 所有验证模块
- **相关决策**: ADR-007, ADR-008

---

### 4. 维护性风险（Maintainability Risks）

#### RISK-009: 知识散落，缺乏中心化追踪
- **风险等级**: 🟡 中危
- **状态**: 🔄 持续改进
- **描述**: 风险点、限制、决策散落在不同文档中，难以全局把握
- **影响范围**: 整个项目
- **发现时间**: 2026-01-13
- **当前缓解**: 
  - 创建本风险点文档 (RISK-POINTS.md)
  - 在关键位置引用本文档
  - 要求 Agent 持续更新
- **未来解决**: 
  - 建立风险审查流程
  - 定期评估和更新风险状态
- **相关代码**: N/A
- **相关决策**: 本文档的创建

---

## 📊 风险统计

| 风险等级 | 数量 | 状态分布 |
|---------|------|----------|
| 🔴 高危 | 1 | ✅ 已解决: 1 |
| 🟡 中危 | 7 | ✅ 已缓解: 2, ⚠️ 已知限制: 3, 🔄 持续改进: 2 |
| 🟢 低危 | 1 | ⚠️ 已知限制: 1 |

**总计**: 9 个已识别风险

---

## 🔍 风险发现流程

### 何时添加新风险？

1. **编译错误时**: 发现语言限制或不支持的特性
2. **实现困难时**: 发现性能问题或实现障碍
3. **Code Review 时**: 发现潜在的安全或维护性问题
4. **用户反馈时**: 发现实际使用中的问题

### 风险记录模板

```markdown
#### RISK-XXX: [风险简述]
- **风险等级**: 🔴 高危 / 🟡 中危 / 🟢 低危
- **状态**: ✅ 已解决 / ✅ 已缓解 / ⚠️ 已知限制 / 🔄 持续改进 / ❌ 未处理
- **描述**: [详细描述风险内容]
- **影响范围**: [受影响的模块/功能]
- **发现时间**: YYYY-MM-DD
- **当前缓解**: [已采取的措施]
- **未来解决**: [计划的解决方案]
- **相关代码**: [受影响的文件]
- **影响任务**: [受影响的任务编号]
- **相关决策**: [相关的 ADR]
```

---

## 🎯 Agent 维护指南

### 强制要求

1. **发现新风险时**:
   - 立即添加到本文档
   - 分配风险编号（递增）
   - 评估风险等级和影响范围
   - 在相关代码中添加注释引用风险编号

2. **实现任务时**:
   - 检查本文档是否有相关风险
   - 如果遇到已知风险，在代码中标注
   - 如果发现新风险，先记录再实现

3. **更新风险状态时**:
   - 风险得到缓解或解决时，更新状态
   - 添加解决方案到相应的 ADR
   - 在 commit message 中引用风险编号

4. **定期审查**:
   - 每完成 10 个任务，审查风险清单
   - 评估是否有新的风险模式
   - 更新统计数据

### 引用风险的格式

在代码注释中:
```verse
# ⚠️ RISK-005: O(n²) 复杂度，大数组慎用
ValidateNoDuplicateInts<public>(Arr:[]int)<decides><transacts>:void =
    ...
```

在文档中:
```markdown
**注意**: 此功能受 RISK-003 (vector3 分量访问限制) 影响，暂缓实现。
```

---

## 📚 相关文档

- **DECISION_RECORDS.md** - 架构决策记录，包含风险缓解决策
- **PATTERNS.md** - 代码模式，包含规避风险的最佳实践
- **CONJECTURES.md** - 猜想记录，未验证的假设可能成为风险
- **COMPILATION_LESSONS.json** - 编译经验，记录了语言限制
- **improvement-backlog.md** - 任务清单，标注受风险影响的任务

---

## 📝 变更历史

| 日期 | 变更内容 | 责任人 |
|------|---------|--------|
| 2026-01-13 | 创建风险点文档，记录 9 个初始风险 | @copilot (Verse Logic Lab) |
| 2026-01-13 | 添加 RISK-001 (递归风险) 的解决方案 | @copilot |

---

**最后更新**: 2026-01-13  
**下次审查**: 完成 10 个任务后 (当前 3/100)
