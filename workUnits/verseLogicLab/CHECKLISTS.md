# Verse Logic Lab - Checklists

这份文档包含 Verse Logic Lab 工作流程的**四个关键检查清单**。在相应阶段开始前，**必须逐项检查**。

---

## ✅ Phase 0: Knowledge Gap Analysis（知识缺口分析）⭐ 新增

在接到任务后，在开始实现前，完成知识充分性评估：

### 0.1 知识资产检查

- [ ] **现有 ADR 检查** - `knowledge/DECISION_RECORDS.md` 中是否有相关决策？
- [ ] **模式库检查** - `knowledge/PATTERNS.md` 中是否有可用模式？
- [ ] **编译经验检查** - `knowledge/COMPILATION_LESSONS.json` 中是否有相关错误经验？
- [ ] **调研报告检查** - `knowledge/research/` 中是否有相关调研？

### 0.2 知识充分性判断

- [ ] **领域知识充分** - 我理解这个功能领域的最佳实践吗？
- [ ] **技术知识充分** - 我了解需要用到的 Verse 特性吗？
- [ ] **参考案例充分** - 我能找到类似的实现参考吗？
- [ ] **决策依据充分** - 如果需要做技术选择，我有足够的依据吗？

### 0.3 前置任务决策

**如果上述检查中有多项为"否"，考虑安排前置任务：**

- [ ] **调研任务** - 是否需要深入调研某个主题？
  - 创建调研计划，预估产出
  - 记录到 `knowledge/improvement-backlog.md`
  
- [ ] **学习任务** - 是否需要深入分析现有优秀模块？
  - 选择 3-5 个相关模块
  - 提取可复用模式
  
- [ ] **重构任务** - 知识资产是否杂乱难检索？
  - 评估重构收益
  - 规划重构范围

**决策标准**：
- ✅ 全新领域且知识为空 → **强制调研**
- ⚠️ 知识不足但有参考 → **建议调研**
- ✅ 知识充分且有案例 → 可直接进入 Phase 1

**输出**：向用户说明评估结果和前置任务计划（如果有）。

---

## ✅ Phase 1: Pre-Implementation Checklist（实现前检查）

在编写任何代码之前，完成以下检查：

### 1.1 需求理解检查

- [ ] **需求目的清晰** - 我理解这个功能的真实目的吗？
- [ ] **简化可能性** - 是否有更简单的方法达成目标？
- [ ] **重复性检查** - 现有的 `logicModules/` 中是否已有类似功能？
- [ ] **依赖合理性** - 这个模块的依赖是否合理？是否引入循环依赖？

### 1.2 范围合规检查（Scope Firewall）

- [ ] **逻辑模块确认** - 这确实是纯逻辑模块，而非组件或 Session？
- [ ] **无 UI 依赖** - 不涉及任何 UI 或可视化相关内容？
- [ ] **目标目录正确** - 代码将放置在 `verseProject/source/library/logicModules/` 下？
- [ ] **跨层检查** - 不会违反架构分层原则？

**如果任何一项为"否"，立即停止并告知用户这超出范围。**

### 1.3 状态与并发安全检查

- [ ] **无状态确认** - 这个模块是否真的无状态？（逻辑模块应为纯函数）
- [ ] **无可变状态** - 不包含可变的全局状态或模块级变量？
- [ ] **无竞态条件** - 没有依赖执行顺序的逻辑？
- [ ] **效果正确性** - 计划使用的效果（`<computes>`, `<decides>`, `<transacts>`）是否正确？

### 1.4 边界条件检查

- [ ] **输入验证** - 是否考虑了无效输入？
- [ ] **数值边界** - 是否考虑了数值溢出、除零、负数等情况？
- [ ] **空值处理** - 是否处理了可能的空值或缺失数据？
- [ ] **极端情况** - 是否考虑了最大值、最小值、空集合等极端情况？

### 1.5 Meta-Cognition（元认知）问题

**花 5 分钟思考以下 Socratic 问题：**

1. **本质追问**
   - 这个功能的本质是什么？
   - 去掉所有细节后，核心问题是什么？

2. **假设质疑**
   - 我对这个需求有哪些隐含假设？
   - 这些假设是否经过验证？

3. **替代方案**
   - 除了直接实现，还有其他方法吗？
   - 是否有现成的库或模块可用？

4. **未来维护**
   - 这个设计是否容易理解和维护？
   - 是否有更优雅的实现方式？

**完成所有检查后，向用户呈现你的分析结果，然后继续到 Phase 2。**

---

## ✅ Phase 2: Code Review Checklist（代码审查检查）

在代码编写完成后，编译前进行以下检查：

### 2.1 代码结构检查

- [ ] **模块声明正确** - 使用 `module_name<public> := module:` 格式？
- [ ] **命名规范** - 函数和类型名称遵循驼峰命名？
- [ ] **注释充分** - 包含模块头部注释和关键函数的说明？
- [ ] **分段清晰** - 使用注释分隔不同功能段（如数据结构、工具函数、核心逻辑）？

### 2.2 类型安全检查

- [ ] **类型签名明确** - 所有公共函数都有完整的类型签名？
- [ ] **效果标注正确** - 每个函数都标注了正确的效果？
  - `<computes>` - 纯计算，无副作用
  - `<decides>` - 条件判断，可能失败
  - `<transacts>` - 事务性操作
- [ ] **返回类型明确** - 函数返回类型清晰，避免隐式推断？
- [ ] **泛型使用合理** - 如果使用泛型，是否真正需要？

### 2.3 纯函数检查

- [ ] **无副作用** - 函数不修改外部状态？
- [ ] **无 IO 操作** - 不涉及文件、网络等 IO？
- [ ] **确定性** - 相同输入总是产生相同输出？
- [ ] **无时间依赖** - 不依赖当前时间或随机数？

### 2.4 错误处理检查

- [ ] **边界保护** - 对输入进行了验证和边界检查？
- [ ] **Fail-Safe** - 在无法继续时使用 `<decides>` 效果优雅失败？
- [ ] **错误传播** - 错误处理逻辑清晰，不吞咽错误？
- [ ] **Clamping 使用** - 数值计算使用了 `Clamp` 或 `Min`/`Max` 保护？

### 2.5 性能考虑

- [ ] **避免重复计算** - 没有不必要的重复计算？
- [ ] **合理的复杂度** - 算法复杂度是否合理？（避免指数级）
- [ ] **内存效率** - 没有不必要的大对象创建？

### 2.6 可测试性检查

- [ ] **函数粒度合理** - 函数不会过大，逻辑清晰？
- [ ] **依赖可注入** - 外部依赖可以通过参数传入？
- [ ] **边界可测试** - 容易构造测试用例验证边界情况？

### 2.7 代码风格检查

- [ ] **缩进一致** - 使用 4 空格缩进？
- [ ] **空行合理** - 在逻辑段之间有适当的空行？
- [ ] **行长度** - 单行不超过 120 字符？
- [ ] **风格统一** - 与现有 `logicModules/` 中的代码风格一致？

**参考现有模块**：查看 `verseProject/source/library/logicModules/characterAndStateUtils/RpgHealth.verse` 作为风格范例。

---

## ✅ Phase 3: Sedimentation Checklist（知识沉淀检查）⭐ 强制执行

代码编译通过后，**必须**完成知识沉淀（不可跳过）：

### 3.1 编译验证

- [ ] **运行分析工具** - 执行了 `cd verseProject && ./analyze.sh --format agent`？
- [ ] **零错误确认** - 分析结果显示 0 错误？
- [ ] **警告处理** - 警告（如果有）已经评估和处理？
- [ ] **退出码检查** - 脚本退出码为 0？

**验证输出示例**：
```
VERSE_ANALYSIS:44:0:0
VERSE_ANALYSIS_END
```

### 3.2 强制知识沉淀（至少完成两项）⭐ 关键

**❌ 不允许的说法**：
- "没有需要记录的" 
- "这个太简单不需要记录"
- "完全遵循现有模式，无需记录"

**✅ 正确的做法**：
- 即使是简单实现，也要记录"验证了 XX 模式在 YY 场景有效"
- 即使完全遵循现有模式，也要添加新的使用案例

#### 3.2.1 ADR 记录（高优先级）

- [ ] **决策识别** - 这次实现中是否有技术决策？（算法选择、模式应用、依赖引入）
- [ ] **决策记录** - 将决策记录到 `knowledge/DECISION_RECORDS.md`
- [ ] **理由充分** - 说明了为什么这样做
- [ ] **替代方案** - 记录了考虑过但未采用的方案

**即使决策看似显而易见，也要记录理由。**

#### 3.2.2 编译经验记录（如遇到错误则强制）

- [ ] **错误记录** - 如果遇到编译错误，记录到 `knowledge/COMPILATION_LESSONS.json`
- [ ] **解决方案** - 清晰记录了解决方法
- [ ] **上下文描述** - 说明了错误发生的场景
- [ ] **预防措施** - 提出了如何避免重复此错误

**如果没有编译错误，跳过此项。**

#### 3.2.3 模式提取（主动发现）

- [ ] **模式识别** - 是否发现了可复用的模式？
- [ ] **模式记录** - 记录到 `knowledge/PATTERNS.md`
- [ ] **使用案例** - 即使模式已存在，也添加了新的使用案例
- [ ] **反模式识别** - 是否发现了应避免的反模式？

**即使是已知模式，新的应用场景也有记录价值。**

#### 3.2.4 调研报告更新（如有调研）

- [ ] **调研验证** - 如果 Phase 0 进行了调研，实现验证了哪些假设？
- [ ] **报告更新** - 更新 `knowledge/research/` 中的相关报告
- [ ] **结论记录** - 将验证结果记录到报告中

**如果没有进行调研，跳过此项。**

### 3.3 知识价值评估（自我检查）

- [ ] **发现新知识** - 我在这次任务中学到了什么新东西？
- [ ] **踩坑记录** - 是否遇到了意外的问题或边界情况？
- [ ] **优化机会** - 是否发现了可以改进的地方（代码或流程）？
- [ ] **知识缺口** - 是否识别出新的知识缺口？记录到 `knowledge/knowledge-gaps.md`

### 3.4 元知识维护（定期执行）

- [ ] **检查清单更新** - 这份 CHECKLISTS.md 是否需要添加新项？
- [ ] **技能文档更新** - `skills/` 下的文档是否需要增强？
- [ ] **改进任务记录** - 将改进想法记录到 `knowledge/improvement-backlog.md`
- [ ] **知识资产整理** - 是否需要重构整理现有知识？

### 3.5 最终确认（必须全部打勾）

- [ ] **至少两项知识沉淀** - 完成了 3.2.1-3.2.4 中的至少两项
- [ ] **知识质量检查** - 记录的内容清晰、可操作、有价值
- [ ] **交叉引用** - 在代码注释或文档中添加了知识资产的交叉引用
- [ ] **未来可检索** - 知识资产有清晰的标题和分类，便于未来检索

**如果未完成知识沉淀，任务视为未完成。**

**记录格式**：
```json
{
  "error": "Ambiguous identifier 'Calculate'",
  "context": "在定义同名函数时未使用模块限定符",
  "solution": "使用完整的模块路径：MyModule.Calculate 而非 Calculate",
  "date": "2026-01-12"
}
```

### 3.3 架构决策记录（ADR）

评估是否需要更新 `knowledge/DECISION_RECORDS.md`：

- [ ] **重要决策识别** - 这次实现中是否有重要的架构或设计决策？
- [ ] **决策理由记录** - 为什么选择这种实现方式？
- [ ] **替代方案说明** - 考虑了哪些替代方案？为什么没选择？
- [ ] **权衡分析** - 这个决策的优缺点是什么？

**需要记录 ADR 的情况**：
- ✅ 选择了特定的算法或数据结构
- ✅ 在多个实现方案中做了取舍
- ✅ 引入了新的依赖或模式
- ✅ 违反了常规做法（有充分理由）

**不需要记录 ADR 的情况**：
- ❌ 简单的工具函数（如类型转换）
- ❌ 完全遵循现有模式的实现
- ❌ 显而易见的实现方式

### 3.4 模式提取

评估是否需要更新 `knowledge/PATTERNS.md`：

- [ ] **通用性评估** - 这个实现是否可以泛化为通用模式？
- [ ] **复用潜力** - 其他模块是否可能需要类似的实现？
- [ ] **最佳实践识别** - 是否发现了值得推广的最佳实践？
- [ ] **反模式识别** - 是否发现了应该避免的反模式？

**值得提取的模式**：
- ✅ 重复出现的计算逻辑（如插值、映射、过滤）
- ✅ 常见的错误处理模式
- ✅ 有效的边界检查方法
- ✅ 优雅的效果组合方式

**不需要提取的模式**：
- ❌ 高度特定于某个领域的逻辑
- ❌ 一次性使用的代码
- ❌ 过于简单的操作（如加法）

### 3.5 可复用性评估

- [ ] **接口设计** - 函数接口是否足够通用，便于复用？
- [ ] **文档完整** - 是否有足够的注释说明用法和限制？
- [ ] **示例充足** - 关键函数是否有使用示例（在注释中）？

### 3.6 知识传播

- [ ] **团队分享** - 是否有值得向团队分享的经验？
- [ ] **文档更新** - 相关的工作单元文档是否需要更新？
- [ ] **检查清单改进** - 这份检查清单本身是否需要改进？

---

## 📊 完成度自检

在任务彻底完成前，确认：

### 知识缺口分析
- ✅ 评估了现有知识的充分性（Phase 0）
- ✅ 如有必要，完成了前置调研任务
- ✅ 知识缺口（如有）已记录

### 代码质量
- ✅ 代码编译通过（0 错误）
- ✅ 代码风格一致
- ✅ 类型安全且有充分的效果标注
- ✅ 边界情况已考虑

### 知识沉淀（强制）⭐
- ✅ 完成了至少两项知识记录（ADR / Lessons / Patterns / Research）
- ✅ 知识记录质量合格（清晰、可操作、有价值）
- ✅ 未来改进点已识别和记录
- ✅ 知识资产更新已提交

### 流程规范
- ✅ 严格遵循四阶段流程（Phase 0-3）
- ✅ 所有检查清单项已完成
- ✅ 范围边界未被违反

**如果知识沉淀未完成，任务视为未完成。**

---

## 🔄 持续改进

这份检查清单是活的文档。每次使用后，思考：

1. 是否有遗漏的检查项？→ 添加到相应 Phase
2. 是否有不必要的检查项？→ 移除或合并
3. 检查项的表述是否清晰？→ 改进描述
4. 是否需要添加更多示例？→ 补充实例

**发现改进点时，立即记录到 `knowledge/improvement-backlog.md`，在下次任务前执行改进。**

---

**记住**：检查清单不是束缚，而是质量保证的伙伴。用心对待每一项检查，产出的代码质量会说话。
