# Verse Logic Lab - Checklists

这份文档包含 Verse Logic Lab 工作流程的三个关键检查清单。在相应阶段开始前，**必须逐项检查**。

---

## ✅ Phase 1: Pre-Implementation Checklist（实现前检查）

在编写任何代码之前，完成以下检查：

### 1.1 需求理解检查

- [ ] **需求目的清晰** - 我理解这个功能的真实目的吗？
- [ ] **简化可能性** - 是否有更简单的方法达成目标？
- [ ] **重复性检查** - 现有的 `logicModules/` 中是否已有类似功能？
- [ ] **依赖合理性** - 这个模块的依赖是否合理？是否引入循环依赖？

### 1.2 范围合规检查（Scope Firewall）

- [ ] **逻辑模块确认** - 这确实是纯逻辑模块，而非组件或 Session？
- [ ] **无 UI 依赖** - 不涉及任何 UI 或可视化相关内容？
- [ ] **目标目录正确** - 代码将放置在 `verseProject/source/library/logicModules/` 下？
- [ ] **跨层检查** - 不会违反架构分层原则？

**如果任何一项为"否"，立即停止并告知用户这超出范围。**

### 1.3 状态与并发安全检查

- [ ] **无状态确认** - 这个模块是否真的无状态？（逻辑模块应为纯函数）
- [ ] **无可变状态** - 不包含可变的全局状态或模块级变量？
- [ ] **无竞态条件** - 没有依赖执行顺序的逻辑？
- [ ] **效果正确性** - 计划使用的效果（`<computes>`, `<decides>`, `<transacts>`）是否正确？

### 1.4 边界条件检查

- [ ] **输入验证** - 是否考虑了无效输入？
- [ ] **数值边界** - 是否考虑了数值溢出、除零、负数等情况？
- [ ] **空值处理** - 是否处理了可能的空值或缺失数据？
- [ ] **极端情况** - 是否考虑了最大值、最小值、空集合等极端情况？

### 1.5 Meta-Cognition（元认知）问题

**花 5 分钟思考以下 Socratic 问题：**

1. **本质追问**
   - 这个功能的本质是什么？
   - 去掉所有细节后，核心问题是什么？

2. **假设质疑**
   - 我对这个需求有哪些隐含假设？
   - 这些假设是否经过验证？

3. **替代方案**
   - 除了直接实现，还有其他方法吗？
   - 是否有现成的库或模块可用？

4. **未来维护**
   - 这个设计是否容易理解和维护？
   - 是否有更优雅的实现方式？

**完成所有检查后，向用户呈现你的分析结果，然后继续到 Phase 2。**

---

## ✅ Phase 2: Code Review Checklist（代码审查检查）

在代码编写完成后，编译前进行以下检查：

### 2.1 代码结构检查

- [ ] **模块声明正确** - 使用 `module_name<public> := module:` 格式？
- [ ] **命名规范** - 函数和类型名称遵循驼峰命名？
- [ ] **注释充分** - 包含模块头部注释和关键函数的说明？
- [ ] **分段清晰** - 使用注释分隔不同功能段（如数据结构、工具函数、核心逻辑）？

### 2.2 类型安全检查

- [ ] **类型签名明确** - 所有公共函数都有完整的类型签名？
- [ ] **效果标注正确** - 每个函数都标注了正确的效果？
  - `<computes>` - 纯计算，无副作用
  - `<decides>` - 条件判断，可能失败
  - `<transacts>` - 事务性操作
- [ ] **返回类型明确** - 函数返回类型清晰，避免隐式推断？
- [ ] **泛型使用合理** - 如果使用泛型，是否真正需要？

### 2.3 纯函数检查

- [ ] **无副作用** - 函数不修改外部状态？
- [ ] **无 IO 操作** - 不涉及文件、网络等 IO？
- [ ] **确定性** - 相同输入总是产生相同输出？
- [ ] **无时间依赖** - 不依赖当前时间或随机数？

### 2.4 错误处理检查

- [ ] **边界保护** - 对输入进行了验证和边界检查？
- [ ] **Fail-Safe** - 在无法继续时使用 `<decides>` 效果优雅失败？
- [ ] **错误传播** - 错误处理逻辑清晰，不吞咽错误？
- [ ] **Clamping 使用** - 数值计算使用了 `Clamp` 或 `Min`/`Max` 保护？

### 2.5 性能考虑

- [ ] **避免重复计算** - 没有不必要的重复计算？
- [ ] **合理的复杂度** - 算法复杂度是否合理？（避免指数级）
- [ ] **内存效率** - 没有不必要的大对象创建？

### 2.6 可测试性检查

- [ ] **函数粒度合理** - 函数不会过大，逻辑清晰？
- [ ] **依赖可注入** - 外部依赖可以通过参数传入？
- [ ] **边界可测试** - 容易构造测试用例验证边界情况？

### 2.7 代码风格检查

- [ ] **缩进一致** - 使用 4 空格缩进？
- [ ] **空行合理** - 在逻辑段之间有适当的空行？
- [ ] **行长度** - 单行不超过 120 字符？
- [ ] **风格统一** - 与现有 `logicModules/` 中的代码风格一致？

**参考现有模块**：查看 `verseProject/source/library/logicModules/characterAndStateUtils/RpgHealth.verse` 作为风格范例。

---

## ✅ Phase 3: Sedimentation Checklist（知识沉淀检查）

代码编译通过后，完成知识沉淀：

### 3.1 编译验证

- [ ] **运行分析工具** - 执行了 `cd verseProject && ./analyze.sh --format agent`？
- [ ] **零错误确认** - 分析结果显示 0 错误？
- [ ] **警告处理** - 警告（如果有）已经评估和处理？
- [ ] **退出码检查** - 脚本退出码为 0？

**验证输出示例**：
```
VERSE_ANALYSIS:44:0:0
VERSE_ANALYSIS_END
```

### 3.2 编译经验记录

- [ ] **错误记录** - 如果遇到编译错误，是否记录到 `knowledge/COMPILATION_LESSONS.json`？
- [ ] **解决方案文档化** - 错误的解决方法是否清晰记录？
- [ ] **上下文说明** - 错误发生的场景是否描述清楚？

**记录格式**：
```json
{
  "error": "Ambiguous identifier 'Calculate'",
  "context": "在定义同名函数时未使用模块限定符",
  "solution": "使用完整的模块路径：MyModule.Calculate 而非 Calculate",
  "date": "2026-01-12"
}
```

### 3.3 架构决策记录（ADR）

评估是否需要更新 `knowledge/DECISION_RECORDS.md`：

- [ ] **重要决策识别** - 这次实现中是否有重要的架构或设计决策？
- [ ] **决策理由记录** - 为什么选择这种实现方式？
- [ ] **替代方案说明** - 考虑了哪些替代方案？为什么没选择？
- [ ] **权衡分析** - 这个决策的优缺点是什么？

**需要记录 ADR 的情况**：
- ✅ 选择了特定的算法或数据结构
- ✅ 在多个实现方案中做了取舍
- ✅ 引入了新的依赖或模式
- ✅ 违反了常规做法（有充分理由）

**不需要记录 ADR 的情况**：
- ❌ 简单的工具函数（如类型转换）
- ❌ 完全遵循现有模式的实现
- ❌ 显而易见的实现方式

### 3.4 模式提取

评估是否需要更新 `knowledge/PATTERNS.md`：

- [ ] **通用性评估** - 这个实现是否可以泛化为通用模式？
- [ ] **复用潜力** - 其他模块是否可能需要类似的实现？
- [ ] **最佳实践识别** - 是否发现了值得推广的最佳实践？
- [ ] **反模式识别** - 是否发现了应该避免的反模式？

**值得提取的模式**：
- ✅ 重复出现的计算逻辑（如插值、映射、过滤）
- ✅ 常见的错误处理模式
- ✅ 有效的边界检查方法
- ✅ 优雅的效果组合方式

**不需要提取的模式**：
- ❌ 高度特定于某个领域的逻辑
- ❌ 一次性使用的代码
- ❌ 过于简单的操作（如加法）

### 3.5 可复用性评估

- [ ] **接口设计** - 函数接口是否足够通用，便于复用？
- [ ] **文档完整** - 是否有足够的注释说明用法和限制？
- [ ] **示例充足** - 关键函数是否有使用示例（在注释中）？

### 3.6 知识传播

- [ ] **团队分享** - 是否有值得向团队分享的经验？
- [ ] **文档更新** - 相关的工作单元文档是否需要更新？
- [ ] **检查清单改进** - 这份检查清单本身是否需要改进？

---

## 📊 完成度自检

在任务彻底完成前，确认：

### 代码质量
- ✅ 代码编译通过（0 错误）
- ✅ 代码风格一致
- ✅ 类型安全且有充分的效果标注
- ✅ 边界情况已考虑

### 知识沉淀
- ✅ 编译经验已记录（如果有错误）
- ✅ 架构决策已记录（如果有重要决策）
- ✅ 可复用模式已提取（如果适用）

### 流程规范
- ✅ 严格遵循三阶段流程
- ✅ 所有检查清单项已完成
- ✅ 范围边界未被违反

---

## 🔄 持续改进

这份检查清单是活的文档。每次使用后，思考：

1. 是否有遗漏的检查项？
2. 是否有不必要的检查项？
3. 检查项的表述是否清晰？
4. 是否需要添加更多示例？

**发现改进点时，立即更新这份文档。**

---

**记住**：检查清单不是束缚，而是质量保证的伙伴。用心对待每一项检查，产出的代码质量会说话。
