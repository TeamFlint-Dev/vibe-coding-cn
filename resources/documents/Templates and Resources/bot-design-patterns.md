# Bot 设计模式

本文档提取自 Telegram Bot 开发经验，总结了通用的 Bot/Agent 设计模式，可作为 AI Agent 开发和游戏 NPC 行为设计的参考。

## 1. 消息处理架构

### 1.1 轮询模式 (Polling)

**特点：**

- 客户端主动定期向服务器请求更新
- 简单易实现，适合开发调试
- 资源消耗较高，有延迟

**适用场景：**

- 开发环境
- 低频交互系统
- 无法配置公网访问的环境

```
┌─────────┐      请求更新      ┌─────────┐
│   Bot   │ ─────────────────> │  Server │
│         │ <───────────────── │         │
└─────────┘      返回事件      └─────────┘
     ↓
  处理事件
     ↓
  发送响应
```

### 1.2 Webhook 模式 (Push)

**特点：**

- 服务器主动推送事件到 Bot
- 实时性高，资源效率高
- 需要公网可访问的 HTTPS 端点

**适用场景：**

- 生产环境
- 高频交互系统
- 需要即时响应的场景

```
┌─────────┐      推送事件      ┌─────────┐
│  Server │ ─────────────────> │   Bot   │
│         │ <───────────────── │ Webhook │
└─────────┘      确认收到      └─────────┘
                                    ↓
                               处理事件
                                    ↓
                               发送响应
```

## 2. 命令处理模式

### 2.1 命令路由器

将不同命令分发到对应的处理函数：

```
用户输入
    ↓
┌─────────────┐
│  命令解析器  │
└─────────────┘
    ↓
┌─────────────────────────────────────┐
│           命令路由表                 │
│  /start  → handleStart()           │
│  /help   → handleHelp()            │
│  /action → handleAction()          │
│  default → handleUnknown()         │
└─────────────────────────────────────┘
```

### 2.2 命令参数解析

```
命令格式：/command arg1 arg2 --flag value

解析结果：
{
  command: "command",
  args: ["arg1", "arg2"],
  flags: { flag: "value" }
}
```

## 3. 状态机模式

### 3.1 会话状态管理

用于多轮对话场景，跟踪用户当前所处的交互阶段：

```
┌──────────┐    输入姓名    ┌──────────┐    输入年龄    ┌──────────┐
│  初始态   │ ────────────> │ 等待姓名  │ ────────────> │ 等待年龄  │
└──────────┘               └──────────┘               └──────────┘
                                                           │
                                                      完成注册
                                                           ↓
                                                    ┌──────────┐
                                                    │  已注册   │
                                                    └──────────┘
```

**状态存储：**

- 内存存储：简单但不持久
- 数据库存储：持久但复杂
- 缓存存储（Redis）：平衡性能与持久性

### 3.2 状态转移表

| 当前状态 | 触发事件 | 下一状态 | 执行动作 |
|---------|---------|---------|---------|
| 初始 | /start | 等待姓名 | 发送"请输入姓名" |
| 等待姓名 | 文本输入 | 等待年龄 | 保存姓名，发送"请输入年龄" |
| 等待年龄 | 数字输入 | 已注册 | 保存年龄，发送"注册成功" |
| 任意 | /cancel | 初始 | 清空数据，发送"已取消" |

## 4. 回调与事件系统

### 4.1 回调数据设计

内联按钮的回调数据应包含足够信息以恢复上下文：

```
回调数据格式：action:context:param

示例：
- "confirm:order:12345"  → 确认订单 12345
- "page:list:3"          → 显示列表第 3 页
- "select:item:abc"      → 选择物品 abc
```

### 4.2 回调处理流程

```
用户点击按钮
      ↓
┌─────────────────┐
│  解析回调数据    │
└─────────────────┘
      ↓
┌─────────────────┐
│  验证请求合法性  │ ← 防止过期或伪造请求
└─────────────────┘
      ↓
┌─────────────────┐
│  执行对应操作    │
└─────────────────┘
      ↓
┌─────────────────┐
│  更新 UI 状态    │ ← 编辑消息或发送新消息
└─────────────────┘
      ↓
┌─────────────────┐
│  反馈用户        │ ← 弹窗提示或触觉反馈
└─────────────────┘
```

## 5. 交互 UI 模式

### 5.1 内联键盘布局

**单选模式：**

```
┌─────────┐ ┌─────────┐ ┌─────────┐
│ 选项 A  │ │ 选项 B  │ │ 选项 C  │
└─────────┘ └─────────┘ └─────────┘
```

**确认/取消模式：**

```
┌─────────┐ ┌─────────┐
│   确认   │ │   取消   │
└─────────┘ └─────────┘
```

**分页模式：**

```
┌─────────┐ ┌─────────┐ ┌─────────┐
│  项目1   │ │  项目2   │ │  项目3   │
└─────────┘ └─────────┘ └─────────┘
┌─────────┐ ┌─────────┐ ┌─────────┐
│    ◀    │ │  2/10   │ │    ▶    │
└─────────┘ └─────────┘ └─────────┘
```

### 5.2 渐进式信息展示

避免一次性发送大量信息，采用分层展示：

```
第一层：概要信息
    ↓ [查看详情]
第二层：详细内容
    ↓ [展开更多]
第三层：完整数据
```

## 6. 错误处理模式

### 6.1 优雅降级

```
try:
    执行主要操作
except 可恢复错误:
    执行备选方案
    通知用户"使用了备选方式"
except 不可恢复错误:
    记录日志
    通知用户"操作失败，请稍后重试"
    提供帮助入口
```

### 6.2 用户友好的错误提示

| 错误类型 | 技术描述 | 用户提示 |
|---------|---------|---------|
| 网络超时 | ConnectionTimeout | "服务繁忙，请稍后重试" |
| 参数错误 | ValidationError | "输入格式不正确，请检查后重试" |
| 权限不足 | PermissionDenied | "您没有权限执行此操作" |
| 资源不存在 | NotFound | "未找到相关内容" |

## 7. 游戏开发中的应用

### 7.1 NPC 对话系统

将 Bot 状态机模式应用于 NPC：

- **状态**：空闲、交谈中、交易中、任务介绍中
- **触发**：玩家接近、对话选项、物品交付
- **响应**：对话文本、动画播放、物品交换

### 7.2 游戏命令系统

将命令路由模式应用于游戏控制台：

```
/spawn enemy_type position
/teleport player_name location
/give item_id quantity
```

### 7.3 事件驱动架构

将回调系统应用于游戏事件：

- UI 按钮点击 → 回调处理 → 状态更新 → UI 刷新
- 游戏事件触发 → 事件分发 → 多系统响应 → 状态同步

## 总结

这些 Bot 设计模式的核心思想可迁移到多种场景：

1. **消息驱动**：所有交互都是消息/事件
2. **状态管理**：清晰的状态定义和转移规则
3. **命令模式**：统一的输入解析和路由
4. **回调机制**：异步操作的标准处理流程
5. **用户体验**：渐进式信息展示和友好的错误处理
