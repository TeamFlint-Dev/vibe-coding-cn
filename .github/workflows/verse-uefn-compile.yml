name: Verse UEFN Compile

on:
  workflow_dispatch:
    inputs:
      request_id:
        description: 'Compile request ID from server'
        required: true
      branch:
        description: 'Branch to compile'
        required: true
      commit:
        description: 'Commit SHA to compile'
        required: true
      callback_url:
        description: 'URL to send result back'
        required: true

jobs:
  compile:
    name: Compile Verse Code
    runs-on: [self-hosted, windows, uefn]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Run Verse Compile via CLI
        id: compile
        shell: pwsh
        run: |
          $startTime = Get-Date
          
          Write-Host "=== Verse UEFN Compile ==="
          Write-Host "Request ID: ${{ inputs.request_id }}"
          Write-Host "Branch: ${{ inputs.branch }}"
          Write-Host "Commit: ${{ inputs.commit }}"
          
          # 使用仓库中的 verse-build.js
          $verseBuildScript = Join-Path $env:GITHUB_WORKSPACE "Core\skills\programming\verseDev\verseCli\verse-build.js"
          
          if (-not (Test-Path $verseBuildScript)) {
            Write-Host "::error::verse-build.js not found at: $verseBuildScript"
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("verse-build.js not found")
              warnings = @()
              duration = "N/A"
            }
            $result | ConvertTo-Json -Compress | Out-File compile_result.json
            exit 0
          }
          
          Write-Host "Using verse-build.js at: $verseBuildScript"
          Write-Host ""
          
          # 运行编译，捕获输出
          $output = ""
          $exitCode = 0
          
          try {
            $output = node $verseBuildScript 2>&1 | Out-String
            $exitCode = $LASTEXITCODE
          } catch {
            $output = $_.Exception.Message
            $exitCode = 1
          }
          
          Write-Host $output
          
          $endTime = Get-Date
          $duration = ($endTime - $startTime).TotalSeconds
          
          # 解析编译输出
          $errors = @()
          $warnings = @()
          
          # 提取错误信息 (格式: path(line,col): error message)
          $errorPattern = '(?<file>[^(]+)\((?<line>\d+),(?<col>\d+)[^)]*\)\s*[：:]\s*(?<msg>.+)'
          $matches = [regex]::Matches($output, $errorPattern)
          
          foreach ($match in $matches) {
            $errorLine = "$($match.Groups['file'].Value):$($match.Groups['line'].Value) - $($match.Groups['msg'].Value)"
            if ($match.Groups['msg'].Value -match 'warning') {
              $warnings += $errorLine
            } else {
              $errors += $errorLine
            }
          }
          
          # 如果没有解析到具体错误但退出码非0，添加通用错误
          if ($exitCode -ne 0 -and $errors.Count -eq 0) {
            # 尝试从输出中提取错误数
            if ($output -match '有\s*(\d+)\s*个错误') {
              $errorCount = [int]$Matches[1]
              $errors += "编译失败，共 $errorCount 个错误 (详见日志)"
            } else {
              $errors += "编译失败 (退出码: $exitCode)"
            }
          }
          
          $success = ($exitCode -eq 0)
          
          $result = @{
            success = $success
            error_count = $errors.Count
            warning_count = $warnings.Count
            errors = $errors
            warnings = $warnings
            duration = "$([math]::Round($duration, 1))s"
            raw_output = $output.Substring(0, [Math]::Min($output.Length, 2000))
          }
          
          Write-Host ""
          Write-Host "=== Compile Result ==="
          Write-Host "Success: $success"
          Write-Host "Errors: $($errors.Count)"
          Write-Host "Warnings: $($warnings.Count)"
          Write-Host "Duration: $([math]::Round($duration, 1))s"
          
          $result | ConvertTo-Json -Depth 3 | Out-File compile_result.json
      
      - name: Send result to server
        if: always()
        shell: pwsh
        env:
          RUNNER_SECRET: ${{ secrets.RUNNER_SECRET }}
        run: |
          $callbackUrl = "${{ inputs.callback_url }}"
          $requestId = "${{ inputs.request_id }}"
          
          # 读取编译结果
          if (Test-Path compile_result.json) {
            $result = Get-Content compile_result.json -Raw | ConvertFrom-Json
          } else {
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("Compile script did not produce result")
              warnings = @()
              duration = "N/A"
            }
          }
          
          # 构建 payload
          $payload = @{
            request_id = $requestId
            success = $result.success
            error_count = $result.error_count
            warning_count = $result.warning_count
            errors = @($result.errors)
            warnings = @($result.warnings)
            duration = $result.duration
            branch = "${{ inputs.branch }}"
            commit = "${{ inputs.commit }}"
          }
          
          $jsonPayload = $payload | ConvertTo-Json -Compress -Depth 3
          
          # 计算签名
          $signature = ""
          if ($env:RUNNER_SECRET) {
            $hmac = New-Object System.Security.Cryptography.HMACSHA256
            $hmac.Key = [System.Text.Encoding]::UTF8.GetBytes($env:RUNNER_SECRET)
            $hash = $hmac.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($jsonPayload))
            $signature = "sha256=" + [BitConverter]::ToString($hash).Replace("-", "").ToLower()
          }
          
          Write-Host "Sending result to: $callbackUrl"
          Write-Host "Request ID: $requestId"
          Write-Host "Success: $($result.success)"
          Write-Host "Errors: $($result.error_count)"
          
          try {
            $headers = @{
              "Content-Type" = "application/json"
            }
            if ($signature) {
              $headers["X-Runner-Signature"] = $signature
            }
            
            Invoke-RestMethod -Uri $callbackUrl -Method Post -Body $jsonPayload -Headers $headers -TimeoutSec 30
            Write-Host "Result sent successfully"
          } catch {
            Write-Host "::warning::Failed to send result: $_"
          }
      
      - name: Upload compile result
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compile-result-${{ inputs.request_id }}
          path: compile_result.json
          retention-days: 7
