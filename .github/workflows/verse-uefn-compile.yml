name: Verse UEFN Compile

on:
  workflow_dispatch:
    inputs:
      request_id:
        description: 'Compile request ID from server'
        required: true
      branch:
        description: 'Branch to compile'
        required: true
      callback_url:
        description: 'URL to send result back'
        required: true

env:
  # UEFN 项目中的仓库路径 (代码库位置)
  UEFN_REPO_PATH: 'E:\Game\FishTycoon\Content\AgentWorkSpace\VibeCodingCN'
  # verse-build.js 工具路径 (reference 子目录)
  VERSE_BUILD_SCRIPT: 'E:\Game\FishTycoon\Content\AgentWorkSpace\VibeCodingCN\tools\reference\verseCompiler\client\verse-build.js'

jobs:
  compile:
    name: Compile Verse Code
    runs-on: [self-hosted, windows, uefn]
    
    steps:
      - name: Setup and sync code
        id: setup
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $startTime = Get-Date
          
          # 保存工作目录路径
          $workDir = Get-Location
          $resultFile = Join-Path $workDir "compile_result.json"
          echo "work_dir=$workDir" >> $env:GITHUB_OUTPUT
          echo "result_file=$resultFile" >> $env:GITHUB_OUTPUT
          
          # 清理旧的编译结果
          if (Test-Path $resultFile) {
            Remove-Item $resultFile -Force
          }
          
          # 辅助函数：生成错误结果
          function Write-ErrorResult {
            param([string]$ErrorMessage, [string]$RawOutput)
            @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @($ErrorMessage)
              warnings = @()
              duration = "N/A"
              raw_output = $RawOutput
            } | ConvertTo-Json -Depth 3 | Out-File $resultFile -Force
          }
          
          $uefnRepo = "${{ env.UEFN_REPO_PATH }}"
          $targetBranch = "${{ inputs.branch }}"
          
          Write-Host "UEFN Repo: $uefnRepo"
          Write-Host "Target Branch: $targetBranch"
          
          if (-not (Test-Path $uefnRepo)) {
            Write-ErrorResult -ErrorMessage "UEFN repo not found at: $uefnRepo" -RawOutput "Path does not exist"
            Write-Host "::error::UEFN repo not found"
            exit 1
          }
          
          Push-Location $uefnRepo
          try {
            $currentBranch = git rev-parse --abbrev-ref HEAD
            
            # 只在需要时切换分支
            if ($currentBranch -ne $targetBranch) {
              Write-Host "Switching from $currentBranch to $targetBranch..."
              git checkout $targetBranch 2>&1 | Out-String | Write-Host
              if ($LASTEXITCODE -ne 0) {
                Write-ErrorResult -ErrorMessage "Failed to checkout branch: $targetBranch" -RawOutput "Checkout failed"
                exit 1
              }
            }
            
            # 只同步 verse 和 tools 文件夹（编译所需的代码和脚本）
            Write-Host "Fetching and syncing verse + tools folders..."
            git fetch origin $targetBranch --depth=1 2>&1 | Out-String | Write-Host
            
            # 使用 checkout 只更新 verse 和 tools 目录
            git checkout "origin/$targetBranch" -- verse/ tools/ 2>&1 | Out-String | Write-Host
            if ($LASTEXITCODE -ne 0) {
              Write-ErrorResult -ErrorMessage "Failed to sync folders" -RawOutput "Checkout failed"
              exit 1
            }
            
            # 获取远程分支的 commit（用于记录）
            $commit = git rev-parse "origin/$targetBranch"
            echo "commit=$commit" >> $env:GITHUB_OUTPUT
            
            $duration = ((Get-Date) - $startTime).TotalSeconds
            Write-Host "Setup completed in $([math]::Round($duration, 1))s, commit: $($commit.Substring(0,7))"
            
          } finally {
            Pop-Location
          }

      - name: Run Verse Compile
        id: compile
        shell: pwsh
        run: |
          $startTime = Get-Date
          
          Write-Host "=== Verse UEFN Compile ==="
          Write-Host "Request ID: ${{ inputs.request_id }}"
          Write-Host "Branch: ${{ inputs.branch }}"
          Write-Host "Commit: ${{ steps.setup.outputs.commit }}"
          
          $verseBuildScript = "${{ env.VERSE_BUILD_SCRIPT }}"
          
          if (-not (Test-Path $verseBuildScript)) {
            Write-Host "::error::verse-build.js not found at: $verseBuildScript"
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("verse-build.js not found")
              warnings = @()
              duration = "N/A"
            }
            $result | ConvertTo-Json -Compress | Out-File compile_result.json
            exit 0
          }
          
          # 运行编译
          $output = ""
          $exitCode = 0
          
          try {
            $output = node $verseBuildScript 2>&1 | Out-String
            $exitCode = $LASTEXITCODE
          } catch {
            $output = $_.Exception.Message
            $exitCode = 1
          }
          
          Write-Host $output
          
          $duration = ((Get-Date) - $startTime).TotalSeconds
          
          # 解析编译输出
          $errors = @()
          $warnings = @()
          
          # 提取错误信息 (格式: path(line,col): error message)
          $errorPattern = '(?<file>[^(]+)\((?<line>\d+),(?<col>\d+)[^)]*\)\s*[：:]\s*(?<msg>.+)'
          $matches = [regex]::Matches($output, $errorPattern)
          
          foreach ($match in $matches) {
            $errorLine = "$($match.Groups['file'].Value):$($match.Groups['line'].Value) - $($match.Groups['msg'].Value)"
            if ($match.Groups['msg'].Value -match 'warning') {
              $warnings += $errorLine
            } else {
              $errors += $errorLine
            }
          }
          
          # 如果没有解析到具体错误但退出码非0，添加通用错误
          if ($exitCode -ne 0 -and $errors.Count -eq 0) {
            # 尝试从输出中提取错误数
            if ($output -match '有\s*(\d+)\s*个错误') {
              $errorCount = [int]$Matches[1]
              $errors += "编译失败，共 $errorCount 个错误 (详见日志)"
            } else {
              $errors += "编译失败 (退出码: $exitCode)"
            }
          }
          
          $success = ($exitCode -eq 0)
          
          $result = @{
            success = $success
            error_count = $errors.Count
            warning_count = $warnings.Count
            errors = $errors
            warnings = $warnings
            duration = "$([math]::Round($duration, 1))s"
            raw_output = $output.Substring(0, [Math]::Min($output.Length, 8000))
          }
          
          Write-Host ""
          Write-Host "=== Compile Result ==="
          Write-Host "Success: $success"
          Write-Host "Errors: $($errors.Count)"
          Write-Host "Warnings: $($warnings.Count)"
          Write-Host "Duration: $([math]::Round($duration, 1))s"
          
          $result | ConvertTo-Json -Depth 3 | Out-File compile_result.json
      
      - name: Send result to server
        if: always()
        shell: pwsh
        env:
          RUNNER_SECRET: ${{ secrets.RUNNER_SECRET }}
        run: |
          $callbackUrl = "${{ inputs.callback_url }}"
          $requestId = "${{ inputs.request_id }}"
          
          # 读取编译结果
          if (Test-Path compile_result.json) {
            $result = Get-Content compile_result.json -Raw | ConvertFrom-Json
          } else {
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("Compile script did not produce result")
              warnings = @()
              duration = "N/A"
            }
          }
          
          # 构建 payload
          $payload = @{
            request_id = $requestId
            success = $result.success
            error_count = $result.error_count
            warning_count = $result.warning_count
            errors = @($result.errors)
            warnings = @($result.warnings)
            duration = $result.duration
            raw_output = if ($result.raw_output) { $result.raw_output } else { "" }
            branch = "${{ inputs.branch }}"
            commit = "${{ steps.setup.outputs.commit }}"
          }
          
          $jsonPayload = $payload | ConvertTo-Json -Compress -Depth 3
          
          # 计算签名
          $signature = ""
          if ($env:RUNNER_SECRET) {
            $hmac = New-Object System.Security.Cryptography.HMACSHA256
            $hmac.Key = [System.Text.Encoding]::UTF8.GetBytes($env:RUNNER_SECRET)
            $hash = $hmac.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($jsonPayload))
            $signature = "sha256=" + [BitConverter]::ToString($hash).Replace("-", "").ToLower()
          }
          
          Write-Host "Sending result: success=$($result.success), errors=$($result.error_count)"
          
          try {
            $headers = @{ "Content-Type" = "application/json" }
            if ($signature) { $headers["X-Runner-Signature"] = $signature }
            
            Invoke-RestMethod -Uri $callbackUrl -Method Post -Body $jsonPayload -Headers $headers -TimeoutSec 10
            Write-Host "Result sent successfully"
          } catch {
            Write-Host "::warning::Failed to send result: $_"
          }

      # NOTE: 移除了 Restore original branch 和 Upload artifact 步骤以提升速度
      # 如果需要调试，可以取消下面的注释
      # - name: Upload compile result
      #   if: failure()
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: compile-result-${{ inputs.request_id }}
      #     path: compile_result.json
      #     retention-days: 3
