name: Verse UEFN Compile

on:
  workflow_dispatch:
    inputs:
      request_id:
        description: 'Compile request ID from server'
        required: true
      branch:
        description: 'Branch to compile'
        required: true
      commit:
        description: 'Commit SHA to compile'
        required: true
      callback_url:
        description: 'URL to send result back'
        required: true

jobs:
  compile:
    name: Compile Verse Code
    runs-on: [self-hosted, windows, uefn]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}
          fetch-depth: 0
      
      - name: Run Verse Compile
        id: compile
        shell: pwsh
        env:
          UEFN_PROJECT: ${{ secrets.UEFN_PROJECT_PATH }}
          VERSE_SOURCE_DIR: ${{ secrets.VERSE_SOURCE_DIR }}
        run: |
          $startTime = Get-Date
          
          # 配置路径
          # UEFN_PROJECT_PATH 指向 Content 目录的父目录，如 E:\Game\FishTycoon
          $uefnProject = $env:UEFN_PROJECT
          if (-not $uefnProject) {
            $uefnProject = "E:\Game\FishTycoon"
          }
          
          # VERSE_SOURCE_DIR 是 Content 目录下的相对路径，如 AgentWorkSpace
          $verseSourceDir = $env:VERSE_SOURCE_DIR
          if (-not $verseSourceDir) {
            $verseSourceDir = "AgentWorkSpace"
          }
          
          $contentDir = Join-Path $uefnProject "Content"
          $verseWorkspace = Join-Path $contentDir $verseSourceDir
          
          Write-Host "=== Verse Compile Configuration ==="
          Write-Host "UEFN Project: $uefnProject"
          Write-Host "Content Dir: $contentDir"
          Write-Host "Verse Workspace: $verseWorkspace"
          Write-Host "Request ID: ${{ inputs.request_id }}"
          Write-Host "Branch: ${{ inputs.branch }}"
          
          # 检查目录是否存在
          if (-not (Test-Path $verseWorkspace)) {
            Write-Host "::error::Verse workspace not found: $verseWorkspace"
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("Verse workspace not found: $verseWorkspace")
              warnings = @()
            }
            $result | ConvertTo-Json -Compress | Out-File compile_result.json
            exit 0
          }
          
          # 列出工作区中的 verse 文件
          $verseFiles = Get-ChildItem -Path $verseWorkspace -Filter "*.verse" -Recurse -ErrorAction SilentlyContinue
          Write-Host "`nFound $($verseFiles.Count) Verse files in workspace"
          
          try {
            # 触发 UEFN 编译
            Write-Host "`n=== Triggering UEFN Compile ==="
            
            # 方案1: 等待 UEFN 自动检测文件变化并编译
            # 方案2: 通过 VSCode 命令触发
            # 方案3: 读取编译日志
            
            $logFile = Join-Path $uefnProject "Saved\Logs\VerseCompile.log"
            $beforeModTime = $null
            if (Test-Path $logFile) {
              $beforeModTime = (Get-Item $logFile).LastWriteTime
            }
            
            # 给 UEFN 时间检测文件变化
            Write-Host "Waiting for UEFN to detect changes..."
            Start-Sleep -Seconds 5
            
            # TODO: 这里需要实际触发编译的机制
            # 可能需要通过 VSCode 扩展或其他方式
            
            # 等待编译完成
            $timeout = 120
            $waited = 0
            $compiled = $false
            
            while ($waited -lt $timeout) {
              if (Test-Path $logFile) {
                $currentModTime = (Get-Item $logFile).LastWriteTime
                if ($beforeModTime -eq $null -or $currentModTime -gt $beforeModTime) {
                  $logContent = Get-Content $logFile -Tail 50 -ErrorAction SilentlyContinue
                  if ($logContent -match "Compile (succeeded|failed|complete)") {
                    $compiled = $true
                    break
                  }
                }
              }
              Start-Sleep -Seconds 2
              $waited += 2
              Write-Host "  Waiting... ($waited seconds)"
            }
            
            # 解析编译结果
            Write-Host "`n=== Parsing Compile Results ==="
            
            $errors = @()
            $warnings = @()
            
            if (Test-Path $logFile) {
              $logContent = Get-Content $logFile -Tail 200 -ErrorAction SilentlyContinue
              
              foreach ($line in $logContent) {
                if ($line -match "error:") {
                  $errors += $line.Trim()
                }
                if ($line -match "warning:") {
                  $warnings += $line.Trim()
                }
              }
            }
            
            $endTime = Get-Date
            $duration = ($endTime - $startTime).TotalSeconds
            
            $success = ($errors.Count -eq 0)
            
            $result = @{
              success = $success
              error_count = $errors.Count
              warning_count = $warnings.Count
              errors = $errors
              warnings = $warnings
              duration = "$([math]::Round($duration, 1))s"
            }
            
            Write-Host "`n=== Compile Result ==="
            Write-Host "Success: $success"
            Write-Host "Errors: $($errors.Count)"
            Write-Host "Warnings: $($warnings.Count)"
            Write-Host "Duration: $([math]::Round($duration, 1))s"
            
            $result | ConvertTo-Json -Compress | Out-File compile_result.json
            
          } catch {
            Write-Host "::error::Exception during compile: $_"
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("Exception: $_")
              warnings = @()
              duration = "N/A"
            }
            $result | ConvertTo-Json -Compress | Out-File compile_result.json
          }
      
      - name: Send result to server
        if: always()
        shell: pwsh
        env:
          RUNNER_SECRET: ${{ secrets.RUNNER_SECRET }}
        run: |
          $callbackUrl = "${{ inputs.callback_url }}"
          $requestId = "${{ inputs.request_id }}"
          
          # 读取编译结果
          if (Test-Path compile_result.json) {
            $result = Get-Content compile_result.json | ConvertFrom-Json
          } else {
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("Compile script did not produce result")
              warnings = @()
              duration = "N/A"
            }
          }
          
          # 添加 request_id
          $payload = @{
            request_id = $requestId
            success = $result.success
            error_count = $result.error_count
            warning_count = $result.warning_count
            errors = $result.errors
            warnings = $result.warnings
            duration = $result.duration
          }
          
          $jsonPayload = $payload | ConvertTo-Json -Compress
          
          # 计算签名
          $signature = ""
          if ($env:RUNNER_SECRET) {
            $hmac = New-Object System.Security.Cryptography.HMACSHA256
            $hmac.Key = [System.Text.Encoding]::UTF8.GetBytes($env:RUNNER_SECRET)
            $hash = $hmac.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($jsonPayload))
            $signature = "sha256=" + [BitConverter]::ToString($hash).Replace("-", "").ToLower()
          }
          
          Write-Host "Sending result to: $callbackUrl"
          Write-Host "Request ID: $requestId"
          Write-Host "Success: $($result.success)"
          
          try {
            $headers = @{
              "Content-Type" = "application/json"
            }
            if ($signature) {
              $headers["X-Runner-Signature"] = $signature
            }
            
            Invoke-RestMethod -Uri $callbackUrl -Method Post -Body $jsonPayload -Headers $headers
            Write-Host "Result sent successfully"
          } catch {
            Write-Host "::warning::Failed to send result: $_"
          }
      
      - name: Upload compile result
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compile-result-${{ inputs.request_id }}
          path: compile_result.json
          retention-days: 7
