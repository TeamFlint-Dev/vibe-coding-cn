name: Verse UEFN Compile

on:
  workflow_dispatch:
    inputs:
      request_id:
        description: 'Compile request ID from server'
        required: true
      branch:
        description: 'Branch to compile'
        required: true
      callback_url:
        description: 'URL to send result back'
        required: true

env:
  # UEFN 项目中的仓库路径 (代码库位置)
  UEFN_REPO_PATH: 'E:\Game\FishTycoon\Content\AgentWorkSpace\VibeCodingCN'
  # verse-build.js 工具路径 (client 子目录)
  VERSE_BUILD_SCRIPT: 'E:\Game\FishTycoon\Content\AgentWorkSpace\VibeCodingCN\scripts\verse-compile-server\client\verse-build.js'

jobs:
  compile:
    name: Compile Verse Code
    runs-on: [self-hosted, windows, uefn]
    
    steps:
      - name: Switch branch in UEFN repo
        id: switch_branch
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $uefnRepo = "${{ env.UEFN_REPO_PATH }}"
          $targetBranch = "${{ inputs.branch }}"
          
          Write-Host "=== Switch Branch in UEFN Repo ==="
          Write-Host "UEFN Repo: $uefnRepo"
          Write-Host "Target Branch: $targetBranch"
          
          if (-not (Test-Path $uefnRepo)) {
            Write-Host "::error::UEFN repo not found at: $uefnRepo"
            exit 1
          }
          
          Push-Location $uefnRepo
          try {
            # 记录当前分支，用于后续恢复
            $originalBranch = git rev-parse --abbrev-ref HEAD
            Write-Host "Original Branch: $originalBranch"
            echo "original_branch=$originalBranch" >> $env:GITHUB_OUTPUT
            
            # 获取最新代码
            Write-Host "Fetching latest from origin..."
            git fetch origin 2>&1 | Write-Host
            if ($LASTEXITCODE -ne 0) {
              Write-Host "::error::Failed to fetch from origin"
              exit 1
            }
            
            # 切换到目标分支
            Write-Host "Switching to branch: $targetBranch"
            git checkout $targetBranch 2>&1 | Write-Host
            if ($LASTEXITCODE -ne 0) {
              Write-Host "::error::Failed to checkout branch: $targetBranch"
              exit 1
            }
            
            # 拉取最新代码
            Write-Host "Pulling latest changes..."
            git pull origin $targetBranch 2>&1 | Write-Host
            if ($LASTEXITCODE -ne 0) {
              Write-Host "::error::Failed to pull branch: $targetBranch"
              exit 1
            }
            
            # 记录当前 commit
            $currentCommit = git rev-parse HEAD
            Write-Host "Current Commit: $currentCommit"
            echo "commit=$currentCommit" >> $env:GITHUB_OUTPUT
            
          } finally {
            Pop-Location
          }
      
      - name: Run Verse Compile
        id: compile
        shell: pwsh
        run: |
          $startTime = Get-Date
          
          Write-Host "=== Verse UEFN Compile ==="
          Write-Host "Request ID: ${{ inputs.request_id }}"
          Write-Host "Branch: ${{ inputs.branch }}"
          Write-Host "Commit: ${{ steps.switch_branch.outputs.commit }}"
          
          $verseBuildScript = "${{ env.VERSE_BUILD_SCRIPT }}"
          
          if (-not (Test-Path $verseBuildScript)) {
            Write-Host "::error::verse-build.js not found at: $verseBuildScript"
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("verse-build.js not found")
              warnings = @()
              duration = "N/A"
            }
            $result | ConvertTo-Json -Compress | Out-File compile_result.json
            exit 0
          }
          
          Write-Host "Using verse-build.js at: $verseBuildScript"
          Write-Host ""
          
          # 运行编译，捕获输出
          $output = ""
          $exitCode = 0
          
          try {
            $output = node $verseBuildScript 2>&1 | Out-String
            $exitCode = $LASTEXITCODE
          } catch {
            $output = $_.Exception.Message
            $exitCode = 1
          }
          
          Write-Host $output
          
          $endTime = Get-Date
          $duration = ($endTime - $startTime).TotalSeconds
          
          # 解析编译输出
          $errors = @()
          $warnings = @()
          
          # 提取错误信息 (格式: path(line,col): error message)
          $errorPattern = '(?<file>[^(]+)\((?<line>\d+),(?<col>\d+)[^)]*\)\s*[：:]\s*(?<msg>.+)'
          $matches = [regex]::Matches($output, $errorPattern)
          
          foreach ($match in $matches) {
            $errorLine = "$($match.Groups['file'].Value):$($match.Groups['line'].Value) - $($match.Groups['msg'].Value)"
            if ($match.Groups['msg'].Value -match 'warning') {
              $warnings += $errorLine
            } else {
              $errors += $errorLine
            }
          }
          
          # 如果没有解析到具体错误但退出码非0，添加通用错误
          if ($exitCode -ne 0 -and $errors.Count -eq 0) {
            # 尝试从输出中提取错误数
            if ($output -match '有\s*(\d+)\s*个错误') {
              $errorCount = [int]$Matches[1]
              $errors += "编译失败，共 $errorCount 个错误 (详见日志)"
            } else {
              $errors += "编译失败 (退出码: $exitCode)"
            }
          }
          
          $success = ($exitCode -eq 0)
          
          $result = @{
            success = $success
            error_count = $errors.Count
            warning_count = $warnings.Count
            errors = $errors
            warnings = $warnings
            duration = "$([math]::Round($duration, 1))s"
            raw_output = $output.Substring(0, [Math]::Min($output.Length, 2000))
          }
          
          Write-Host ""
          Write-Host "=== Compile Result ==="
          Write-Host "Success: $success"
          Write-Host "Errors: $($errors.Count)"
          Write-Host "Warnings: $($warnings.Count)"
          Write-Host "Duration: $([math]::Round($duration, 1))s"
          
          $result | ConvertTo-Json -Depth 3 | Out-File compile_result.json
      
      - name: Send result to server
        if: always()
        shell: pwsh
        env:
          RUNNER_SECRET: ${{ secrets.RUNNER_SECRET }}
        run: |
          $callbackUrl = "${{ inputs.callback_url }}"
          $requestId = "${{ inputs.request_id }}"
          
          # 读取编译结果
          if (Test-Path compile_result.json) {
            $result = Get-Content compile_result.json -Raw | ConvertFrom-Json
          } else {
            $result = @{
              success = $false
              error_count = 1
              warning_count = 0
              errors = @("Compile script did not produce result")
              warnings = @()
              duration = "N/A"
            }
          }
          
          # 构建 payload
          $payload = @{
            request_id = $requestId
            success = $result.success
            error_count = $result.error_count
            warning_count = $result.warning_count
            errors = @($result.errors)
            warnings = @($result.warnings)
            duration = $result.duration
            branch = "${{ inputs.branch }}"
            commit = "${{ steps.switch_branch.outputs.commit }}"
          }
          
          $jsonPayload = $payload | ConvertTo-Json -Compress -Depth 3
          
          # 计算签名
          $signature = ""
          if ($env:RUNNER_SECRET) {
            $hmac = New-Object System.Security.Cryptography.HMACSHA256
            $hmac.Key = [System.Text.Encoding]::UTF8.GetBytes($env:RUNNER_SECRET)
            $hash = $hmac.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($jsonPayload))
            $signature = "sha256=" + [BitConverter]::ToString($hash).Replace("-", "").ToLower()
          }
          
          Write-Host "Sending result to: $callbackUrl"
          Write-Host "Request ID: $requestId"
          Write-Host "Success: $($result.success)"
          Write-Host "Errors: $($result.error_count)"
          
          try {
            $headers = @{
              "Content-Type" = "application/json"
            }
            if ($signature) {
              $headers["X-Runner-Signature"] = $signature
            }
            
            Invoke-RestMethod -Uri $callbackUrl -Method Post -Body $jsonPayload -Headers $headers -TimeoutSec 30
            Write-Host "Result sent successfully"
          } catch {
            Write-Host "::warning::Failed to send result: $_"
          }
      
      - name: Restore original branch
        if: always()
        shell: pwsh
        run: |
          $uefnRepo = "${{ env.UEFN_REPO_PATH }}"
          $originalBranch = "${{ steps.switch_branch.outputs.original_branch }}"
          
          if (-not $originalBranch) {
            Write-Host "No original branch to restore"
            exit 0
          }
          
          Write-Host "=== Restore Original Branch ==="
          Write-Host "Restoring to: $originalBranch"
          
          Push-Location $uefnRepo
          try {
            git checkout $originalBranch
            Write-Host "Restored to branch: $originalBranch"
          } catch {
            Write-Host "::warning::Failed to restore branch: $_"
          } finally {
            Pop-Location
          }
      
      - name: Upload compile result
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compile-result-${{ inputs.request_id }}
          path: compile_result.json
          retention-days: 7
